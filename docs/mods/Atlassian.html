<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Atlassian API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Atlassian</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

import requests, os, json, time, re, gc, getpass
import urllib.parse

from datetime     import datetime

from bs4          import BeautifulSoup
from urllib       import parse
from urllib.parse import parse_qs
from urllib.parse import urlparse

from macwinnie_pyhelpers.Browser import Browser

from selenium                                       import webdriver
from selenium.common.exceptions                     import NoSuchElementException
from selenium.webdriver.common.keys                 import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from selenium.webdriver.common.by                   import By
from selenium.webdriver.support.wait                import WebDriverWait
from selenium.webdriver.support                     import expected_conditions as EC
from selenium.webdriver.common.action_chains        import ActionChains

class Atlassian ( Browser ):
    &#34;&#34;&#34;Special functions for Atlassian systems – they need to have `nosso` active at least ...&#34;&#34;&#34;

    def webSudo( self, authUrl, sysInfoUrl, adjustCookies = True ):
        &#34;&#34;&#34;run the application webSudo&#34;&#34;&#34;
        if not self.checkLogin():
            self.login()
        self.browser.get( sysInfoUrl )
        pwFieldXPath = &#39;//input[@type=&#34;password&#34;]&#39;
        doWebSudo = (
                        self.browser.current_url != sysInfoUrl
                    ) or (
                        self.checkElementByXpath( pwFieldXPath )
                    )
        if doWebSudo:
            self.browser.get( authUrl )
            pwfield = WebDriverWait( self.browser, 10 ).until( EC.presence_of_element_located( ( By.XPATH, pwFieldXPath ) ) )
            pwfield.send_keys( Keys.CONTROL, &#34;a&#34; )
            pwfield.send_keys( self.app[ &#39;passwd&#39; ] )
            pwfield.send_keys( Keys.ENTER )
            time.sleep( 5 )
            if adjustCookies:
                self.refresh()

    def getToken( self ):
        &#34;&#34;&#34;get CSRF token of Atlassian App&#34;&#34;&#34;
        self.get( self.app[&#39;url&#39;] )
        return self.browser.find_element( By.ID, &#39;atlassian-token&#39; ).get_attribute( &#39;content&#39; )


class Jira ( Atlassian ):
    &#34;&#34;&#34;Jira Browser – recommended to use administrative user; otherwise most functions won&#39;t work properly&#34;&#34;&#34;

    appInfo = {
        &#34;url&#34;:    {
            &#34;env&#34;:         &#34;JIRA_URL&#34;,
            &#34;url&#34;:         True,
            &#34;description&#34;: &#34;Enter Jira URL&#34;,
        },
        &#34;user&#34;:   {
            &#34;env&#34;:         &#34;JIRA_USER&#34;,
            &#34;description&#34;: &#34;Enter Jira username&#34;,
        },
        &#34;passwd&#34;: {
            &#34;password&#34;:    True,
            &#34;env&#34;:         &#34;JIRA_PASS&#34;,
            &#34;description&#34;: &#34;Enter Jira password&#34;,
        },
    }

    projectKeys  = []
    permissions  = {}
    projectLeads = {}

    def __init__( self ):
        super( Jira, self ).__init__()

    def setSessionBaseHeaders( self, api=False ):
        &#34;&#34;&#34;Api requests need special headers in Jira ... sometimes ...&#34;&#34;&#34;
        if not api:
            self.sessionBaseHeaders = None
        else:
            self.sessionBaseHeaders = {
                &#34;Content-Type&#34;:      &#34;application/json&#34;,
                &#34;X-Atlassian-Token&#34;: &#34;no-check&#34;
            }

    def login( self, skipSSO=True ):
        &#34;&#34;&#34;Run Jira login&#34;&#34;&#34;
        loginUrl = self.app[ &#39;url&#39; ] + &#34;login.jsp&#34;
        if skipSSO:
            loginUrl += &#39;?nosso&#39;
        self.loadCookies( url=loginUrl )
        self.setSessionBaseHeaders()
        userObject = { &#34;os_username&#34;: self.app[ &#39;user&#39; ], &#34;os_password&#34;: self.app[ &#39;passwd&#39; ], }
        if os.getenv( &#34;PRINT_DEBUG_INFO&#34;, &#34;False&#34; ).lower() in [ &#34;1&#34;, &#34;true&#34;, &#34;t&#34;, &#34;y&#34;, &#34;yes&#34; ]:
            print( &#39;User is being logged in with those credentials:&#39; )
            print( userObject )
            print()
        self.sessionPostRequest( loginUrl, userObject, True, urlOverride=True )
        self.get( self.app[ &#39;url&#39; ] , False )

    def checkLogin( self ):
        &#34;&#34;&#34;Check if login is needed&#34;&#34;&#34;
        currentUrl = self.browser.current_url
        urlLen     = len( self.app[ &#39;url&#39; ] )
        if currentUrl[ 0:urlLen ] != self.app[ &#39;url&#39; ]:
            self.get( self.app[ &#39;url&#39; ], False )
        try:
            self.browser.find_element( By.ID, &#39;login&#39; )
            return False
        except:
            return True

    def webSudo( self, adjustCookies = True ):
        &#34;&#34;&#34;Run the Jira WebSudo&#34;&#34;&#34;
        authUrl    = &#39;{url}secure/admin/WebSudoAuthenticate!default.jspa&#39;.format( url=self.app[ &#39;url&#39; ] )
        sysInfoUrl = &#39;{url}secure/admin/ViewApplicationProperties.jspa&#39;.format( url=self.app[ &#39;url&#39; ] )
        super( Jira, self ).webSudo( authUrl, sysInfoUrl, adjustCookies )

    def getProjectKeys( self ):
        &#34;&#34;&#34;Get a list of Project Keys of those Jira projects visible to logged in user&#34;&#34;&#34;
        self.webSudo()
        self.get( self.app[ &#39;url&#39; ] + &#39;secure/project/BrowseProjects.jspa&#39; )
        while True:
            soup = self.toSoup()
            self.projectKeys += [ item.text for item in soup.select( &#39;tbody tr .cell-type-key&#39; ) ]
            try:
                nextBtn = soup.select( &#39;.aui-nav-next a&#39; )[0]
                check   = nextBtn[ &#39;data-page&#39; ]
                self.browser.find_element( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, normalize-space(@class), &#34; &#34;), &#34; aui-nav-next &#34;)]//a&#39; ).click()
                time.sleep(5)
            except:
                break
        return self.projectKeys

    def getUserGroups( self, username, session=None ):
        &#34;&#34;&#34;Function to gather groups of user&#34;&#34;&#34;
        apiUrl = &#39;{url}rest/api/2/user?username={user}&amp;expand=groups&#39;.format( url=self.app[&#39;url&#39;], user=urllib.parse.quote( username ) )
        groups = self.apiGetInfo( apiUrl, session=session )
        return [ g[&#39;name&#39;] for g in groups[&#39;groups&#39;][&#39;items&#39;] ]

    def getUserApiInfo( self, username, returnResponse=False, session=None ):
        &#34;&#34;&#34;Function to gather information about a user from API – if `returnResponse` is True, the whole request response is returned, otherwise only the decoded answer object&#34;&#34;&#34;
        apiUrl = &#39;{url}rest/api/2/user?username={user}&#39;.format( url=self.app[&#39;url&#39;], user=urllib.parse.quote( username ) )
        return self.apiGetInfo( apiUrl, returnResponse, session )

    def getGroupApiInfo( self, groupname, returnResponse=False, session=None ):
        &#34;&#34;&#34;Function to gather information about a group from API – if `returnResponse` is True, the whole request response is returned, otherwise only the decoded answer object&#34;&#34;&#34;
        apiUrl = &#39;{url}rest/api/2/group?groupname={group}&#39;.format( url=self.app[&#39;url&#39;], group=urllib.parse.quote( groupname ) )
        return self.apiGetInfo( apiUrl, returnResponse, session )

    def gatherProjectPermissions( self, projectKey, session=None ):
        &#34;&#34;&#34;Function to gather permissions for a specific Jira project&#34;&#34;&#34;
        rolesDropdownXpath = &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; iLKsB &#34;)]&#39;
        projectPermissions = None
        self.get( &#39;{url}plugins/servlet/project-config/{pjkey}/roles&#39;.format( url=self.app[&#39;url&#39;], pjkey=projectKey ) )
        skip = True
        try:
            WebDriverWait( self.browser, 10 ).until( EC.presence_of_element_located( ( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; EKGYc &#34;)]&#39; ) ) )
            skip = False
        except:
            print( &#39;{p} skipped&#39;.format( p = projectKey ) )
        if not skip:
            projectPermissions = {}
            continueLookup = True
            # retrieve possible roles
            roleBtn = WebDriverWait( self.browser, 10 ).until(EC.element_to_be_clickable((By.XPATH, &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; css-18u3ks8 &#34;)]&#39;)))
            roleBtn.click()
            # wait until dropdown is visible
            WebDriverWait( self.browser, 10 ).until(EC.presence_of_element_located((By.XPATH, rolesDropdownXpath)))
            # kteeYD (selected, single one), goEvqh (selected, multiple ones), eJTYOK (not selected)
            roleElements = self.browser.find_elements( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; eJTYOk &#34;) or contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; goEvqh &#34;) or contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; kteeYD &#34;)]&#39; )
            for rl in roleElements:
                role = re.match( r&#39;^(.+?)(\s\([0-9]+\))?$&#39; ,rl.text ).group( 1 )
                projectPermissions[ role ] = {&#39;USERS&#39;:[], &#39;GROUPS&#39;:[]}
            try:
                roleBtn.click()
                WebDriverWait( self.browser, 10 ).until_not(EC.presence_of_element_located((By.XPATH, rolesDropdownXpath)))
            except:
                actions = ActionChains( self.browser )
                actions.send_keys( Keys.ESCAPE )
                actions.perform()
                WebDriverWait( self.browser, 10 ).until_not(EC.presence_of_element_located((By.XPATH, rolesDropdownXpath)))
            while continueLookup:
                # find all username and groupname fields on page
                nameFields = self.browser.find_elements( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; EKGYc &#34;)]&#39; )
                # fetch users for roles
                for x in nameFields:
                    n = x.text
                    trigger = x.find_element( By.XPATH, &#39;./parent::*/parent::*/parent::*/parent::*//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; css-8xpfx5 &#34;)]&#39; )
                    resp = self.getUserApiInfo( n, True, session )
                    index = None
                    if ( resp.status_code == 200 ):
                        index = &#39;USERS&#39;
                    else:
                        resp = self.getGroupApiInfo( n, True, session )
                        if ( resp.status_code == 200 ):
                            index = &#39;GROUPS&#39;
                    if index != None:
                        try:
                            trigger.click()
                            WebDriverWait( self.browser, 10 ).until(EC.presence_of_element_located((By.XPATH, rolesDropdownXpath)))
                            clicked = True
                        except:
                            actions = ActionChains( self.browser )
                            actions.send_keys( Keys.ESCAPE )
                            actions.perform()
                            try:
                                WebDriverWait( self.browser, 10 ).until(EC.presence_of_element_located((By.XPATH, rolesDropdownXpath)))
                            except Exception as e:
                                self.browser.get_screenshot_as_file(&#39;./data/debug/error_{index}_open_{date}.png&#39;.format( date = datetime.now().strftime(&#34;%Y%m%d_%H%M%S&#34;), index=index ))
                                raise e
                        roleElements = self.browser.find_elements( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; kteeYD &#34;) or contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; goEvqh &#34;)]&#39; )
                        for rl in roleElements:
                            projectPermissions[ rl.text ][ index ].append( n )
                        try:
                            trigger.click()
                            WebDriverWait( self.browser, 10 ).until_not(EC.presence_of_element_located((By.XPATH, rolesDropdownXpath)))
                            clicked = True
                        except:
                            actions = ActionChains( self.browser )
                            actions.send_keys( Keys.ESCAPE )
                            actions.perform()
                            try:
                                WebDriverWait( self.browser, 10 ).until_not(EC.presence_of_element_located((By.XPATH, rolesDropdownXpath)))
                            except Exception as e:
                                self.browser.get_screenshot_as_file(&#39;./data/debug/error_{index}_close_{date}.png&#39;.format( date = datetime.now().strftime(&#34;%Y%m%d_%H%M%S&#34;), index=index ))
                                raise e
                try:
                    self.browser.find_element( By.XPATH, &#39;//*[@aria-label=&#34;Next&#34; and not(@disabled)]&#39; ).click()
                except:
                    continueLookup = False
        return projectPermissions

    def getGroups( self ):
        &#34;&#34;&#34;get list of groupnames existing in Jira&#34;&#34;&#34;
        session = self.toSession()
        rspJ = session.get( &#39;{url}rest/api/2/groups/picker?maxResults={limit}&#39;.format( url=self.app[ &#39;url&#39; ], limit=5000 ) )
        jgroups = []
        if rspJ.status_code == 200:
            rsp = json.loads( rspJ.text )
            for g in rsp[&#39;groups&#39;]:
                jgroups.append( g[ &#39;name&#39; ] )
        return jgroups

    def removeUserFromGroup( self, group, user, session=None ):
        &#34;&#34;&#34;Remove user from group&#34;&#34;&#34;
        if session == None:
            session = self.toSession( curl = True )
        requestData = {
            &#39;groupname&#39;: group,
            &#39;username&#39;:  user
        }
        rsp = session.delete( &#39;{url}rest/api/2/group/user?{params}&#39;.format( url=self.app[ &#39;url&#39; ], params=urllib.parse.urlencode( requestData ) ) )
        return rsp

    def addUserToGroup( self, group, user, session=None ):
        &#34;&#34;&#34;Add user to group&#34;&#34;&#34;
        if session == None:
            session = self.toSession( curl = True )
        rsp = session.post( &#39;{url}rest/api/2/group/user?groupname={group}&#39;.format(url=self.app[&#39;url&#39;], group=group), data = json.dumps({&#39;name&#39;:user}), headers={&#39;content-type&#39;:&#39;application/json&#39;} )
        return rsp

    def getGroupMembers( self, group, activeFilter=&#39;true&#39; ):
        &#34;&#34;&#34;get group members from GUI&#34;&#34;&#34;
        self.webSudo()
        self.setSessionBaseHeaders()
        self.sessionPostRequest( &#39;{url}secure/admin/user/UserBrowser.jspa&#39;.format( url=self.app[&#39;url&#39;] ), { &#39;userSearchFilter&#39;: &#39;&#39;, &#39;group&#39;: group, &#39;applicationFilter&#39;: &#39;&#39;, &#39;activeFilter&#39;: activeFilter, &#39;max&#39;: 1000000 } , True )
        should = WebDriverWait( self.browser, 10 ).until( EC.presence_of_element_located( ( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; results-count &#34;)]//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; results-count-total &#34;)]&#39; ) ) ).text
        gms    = self.browser.find_elements( By.XPATH, &#39;//*[@data-cell-type=&#34;username&#34;]/ancestor::tr[position() = 1]&#39; )
        if len(gms) != int(should):
            raise Exception(&#39;Count-Missmatch with group members of &#34;{g}&#34;: {f} found, but {s} should have!&#39;.format(g=group, f=len(gms), s=should))
        users = []
        for i in gms:
            users.append( i.get_attribute( &#34;data-user&#34; ) )
        return users

    def getGroupMembersAPI( self, group ):
        &#34;&#34;&#34;get group members from API – sometimes a little bit buggy ...&#34;&#34;&#34;
        sessionJ = self.toSession()
        stop = False
        i = 0
        users = []
        while True:
            limit = 50
            parameters = {
                &#39;groupname&#39;: group,
                &#39;startAt&#39;: ( i * limit ),
                &#39;maxResults&#39;: limit,
                &#39;includeInactiveUsers&#39;: &#39;false&#39;,
            }
            memberUrl = &#39;{url}rest/api/2/group/member?{params}&#39;.format( url=self.app[ &#39;url&#39; ], params=urllib.parse.urlencode( parameters ) )
            rspJ = sessionJ.get( memberUrl )

            if rspJ.status_code == 200:
                rsp = json.loads( rspJ.text )
                if rsp[ &#39;isLast&#39; ] == True:
                    stop = True
                for u in rsp[&#39;values&#39;]:
                    users.append( u[ &#39;name&#39; ] )
            else:
                print(&#39;rc: &#39; + str(rspJ.status_code))
                print(parameters)
                stop = True

            if stop or len( rsp[&#39;values&#39;] ) == 0:
                len( rsp[&#39;values&#39;] )
                break
            else:
                i += 1
        return users

    def getActiveProjectLead( self, projectKey, session=None ):
        &#34;&#34;&#34;Function to retrieve project lead of Jira project, if the user is still active&#34;&#34;&#34;
        if session == None:
            session = self.toSession()
        self.browser.get( &#39;{url}plugins/servlet/project-config/{pjkey}/roles&#39;.format( url=self.app[&#39;url&#39;], pjkey=projectKey ) )
        plo = WebDriverWait( self.browser, 10 ).until( EC.presence_of_element_located( ( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; jKQrhX &#34;)]//a&#39; ) ) )
        parsedProfile = urlparse( plo.get_attribute(&#39;href&#39;) )
        ploUser = parse_qs(parsedProfile.query)[&#39;name&#39;][0]
        resp = session.get( &#39;{url}rest/api/2/user?username={user}&#39;.format( url=self.app[&#39;url&#39;], user=urllib.parse.quote( ploUser ) ) )
        try:
            userJson = json.loads( resp.text )
            active = userJson[&#39;active&#39;]
        except:
            active = False
        if ( resp.status_code == 200 and active):
            return ploUser
        else:
            return None

    def getProjectLeads( self ):
        &#34;&#34;&#34;Function to retrieve active project leads for all Jira projects&#34;&#34;&#34;
        if len( self.projectKeys ) == 0:
            self.getProjectKeys()
        if len( self.projectLeads ) == 0:
            session = self.toSession()
            for pk in self.projectKeys:
                self.projectLeads[ projectKey ] = self.getActiveProjectLead( pk, session )
        return self.projectLeads

    def gatherAllProjectPermissions( self, deletePermissionHelperFile=True ):
        &#34;&#34;&#34;Function to retrieve project permissions for all projects&#34;&#34;&#34;
        if len( self.projectKeys ) == 0:
            self.getProjectKeys()
        if len( self.permissions ) == 0:
            permissionHelperFile = &#39;./data/projectPermissionsHelper.json&#39;
            session = self.toSession()
            if not os.path.exists( os.path.dirname( permissionHelperFile ) ):
                os.makedirs( os.path.dirname( permissionHelperFile ), exist_ok=True)
            if not os.path.exists( permissionHelperFile ):
                with open( permissionHelperFile, &#39;w+&#39;):
                    pass
            with open( permissionHelperFile ) as json_file:
                self.permissions = json.load( json_file )
            for pk in self.projectKeys:
                if pk not in self.permissions:
                    print( pk )
                    self.permissions[ pk ] = self.gatherProjectPermissions( pk, session )
                with open( permissionHelperFile, &#39;w&#39; ) as json_file:
                        json.dump( self.permissions, json_file )
            print()
            if deletePermissionHelperFile:
                os.remove( permissionHelperFile )
        return self.permissions

    def createGroup( self, groupName ):
        &#34;&#34;&#34;Create a local user group&#34;&#34;&#34;
        groupUrl = self.app[ &#39;url&#39; ] + &#39;/secure/admin/user/GroupBrowser.jspa&#39;
        self.get( groupUrl )
        field = self.browser.find_element( By.XPATH, &#39;//input[@name=&#34;addName&#34;]&#39; )
        field.send_keys( Keys.CONTROL, &#34;a&#34; )
        field.send_keys( groupName )
        field.send_keys( Keys.ENTER )
        session = self.toSession()
        groupCreated = False
        while not groupCreated:
            time.sleep(1)
            rsp = session.get( &#39;{url}rest/api/latest/group?groupname={group}&#39;.format( url=self.app[ &#39;url&#39; ], group=urllib.parse.quote( groupName ) ) )
            groupCreated = ( rsp.status_code == 200 )


class Confluence ( Atlassian ):
    &#34;&#34;&#34;Confluence Browser – recommended to use administrative user; otherwise most functions won&#39;t work properly&#34;&#34;&#34;

    spaceKeys        = []
    spaceNames       = {}
    permissions      = {}
    permissionsNames = []
    appInfo = {
        &#34;url&#34;:    {
            &#34;env&#34;:         &#34;CONFLUENCE_URL&#34;,
            &#34;url&#34;:         True,
            &#34;description&#34;: &#34;Enter Confluence URL&#34;,
        },
        &#34;user&#34;:   {
            &#34;env&#34;:         &#34;CONFLUENCE_USER&#34;,
            &#34;description&#34;: &#34;Enter Confluence username&#34;,
        },
        &#34;passwd&#34;: {
            &#34;password&#34;:    True,
            &#34;env&#34;:         &#34;CONFLUENCE_PASS&#34;,
            &#34;description&#34;: &#34;Enter Confluence password&#34;,
        },
    }

    def __init__( self ):
        super( Confluence, self ).__init__()

    def login( self, skipSSO=True ):
        &#34;&#34;&#34;Run Confluence login&#34;&#34;&#34;
        loginUrl = self.app[ &#39;url&#39; ] + &#34;dologin.action&#34;
        if skipSSO:
            loginUrl += &#39;?nosso&#39;
        self.loadCookies( url=loginUrl )
        self.setSessionBaseHeaders()
        userObject = { &#34;os_username&#34;: self.app[ &#39;user&#39; ], &#34;os_password&#34;: self.app[ &#39;passwd&#39; ], &#34;os_cookie&#34;: &#34;true&#34;, &#34;login&#34;: &#34;Log in&#34;, &#34;os_destination&#34;: &#34;&#34;, }
        if os.getenv( &#34;PRINT_DEBUG_INFO&#34;, &#34;False&#34; ).lower() in [ &#34;1&#34;, &#34;true&#34;, &#34;t&#34;, &#34;y&#34;, &#34;yes&#34; ]:
            print( &#39;User is being logged in with those credentials:&#39; )
            print( userObject )
            print()
        self.sessionPostRequest( loginUrl, userObject, True, urlOverride=True )
        self.get( self.app[ &#39;url&#39; ] , False )

    def checkLogin( self ):
        &#34;&#34;&#34;Check if login is needed&#34;&#34;&#34;
        currentUrl = self.browser.current_url
        urlLen     = len( self.app[ &#39;url&#39; ] )
        if currentUrl[ 0:urlLen ] != self.app[ &#39;url&#39; ]:
            self.get( self.app[ &#39;url&#39; ], False )
        try:
            self.browser.find_element( By.ID, &#39;loginButton&#39; )
            return False
        except:
            return True

    def setSessionBaseHeaders( self, api=False ):
        &#34;&#34;&#34;Api requests need special headers in Confluence ... sometimes ...&#34;&#34;&#34;
        if not api:
            self.sessionBaseHeaders = None
        else:
            self.sessionBaseHeaders = {
                &#34;Content-Type&#34;:      &#34;application/json&#34;,
                &#34;X-Atlassian-Token&#34;: &#34;no-check&#34;
            }

    def getPageInfo( self, spaceKey, title, session=None ):
        &#34;&#34;&#34;Function to get page information by Confluence space key and page title&#34;&#34;&#34;
        self.setSessionBaseHeaders( api=True )
        parameters = {
            &#39;spaceKey&#39;: spaceKey,
            &#39;title&#39;:    title,
            &#39;expand&#39;:   &#39;version,space&#39;,
        }
        apiUrl  = &#39;{url}rest/api/content?{params}&#39;.format( url=self.app[ &#39;url&#39; ], params=urllib.parse.urlencode( parameters ) )
        results = self.apiGetInfo( apiUrl, session=session )
        if results[ &#39;size&#39; ] &gt; 1:
            raise Exception( &#39;More than one page found – cannot proceed properly ...&#39; )
        return results[ &#39;results&#39; ][ 0 ]

    def getPageInfoByID( self, pageID, session=None ):
        &#34;&#34;&#34;Function to get page information by page ID&#34;&#34;&#34;
        self.setSessionBaseHeaders( api=True )
        parameters = {
            &#39;expand&#39;:   &#39;version,space&#39;,
        }
        apiUrl = &#39;{url}rest/api/content/{id}?{params}&#39;.format( url=self.app[ &#39;url&#39; ], id=pageID, params=urllib.parse.urlencode( parameters ) )
        result = self.apiGetInfo( apiUrl, session=session )
        return result

    def getSpaceName( self, spaceKey, session=None ):
        &#34;&#34;&#34;Helper function to retrieve the space name of a Confluence Space&#34;&#34;&#34;
        self.setSessionBaseHeaders( api=True )
        apiUrl = &#39;{url}rest/api/space/{spaceKey}&#39;.format( url=self.app[ &#39;url&#39; ], spaceKey=spaceKey )
        result = self.apiGetInfo( apiUrl, session=session )
        if result != None:
            return result[ &#39;name&#39; ]

    def getSpaceKeyFromName( self, spaceName, force=False, session=None ):
        &#34;&#34;&#34;Helper function to retrieve space key by space name&#34;&#34;&#34;
        if len( self.spaceNames ) == 0 or force == True:
            sks = self.getSpaceKeys()
            for sk in sks:
                self.spaceNames[ self.getSpaceName( sk ) ] = sk
        if spaceName in self.spaceNames:
            return self.spaceNames[ spaceName ]

    def getSpaceHomepageID( self, spaceKey, session=None ):
        &#34;&#34;&#34;Helper function to get page ID of homepage of Space&#34;&#34;&#34;
        self.setSessionBaseHeaders( api=True )
        parameters = {
            &#39;expand&#39;:   &#39;homepage&#39;,
            &#39;spaceKey&#39;: spaceKey,
        }
        apiUrl = &#39;{url}rest/api/space?{params}&#39;.format( url=self.app[ &#39;url&#39; ], id=pageID, params=urllib.parse.urlencode( parameters ) )
        result = self.apiGetInfo( apiUrl, session=session )
        if result != None:
            return result[ &#39;results&#39; ][ 0 ][ &#39;homepage&#39; ][ &#39;id&#39; ]

    def createPage( self, title, contentHtml, spaceKey, parent=None, session=None ):
        &#34;&#34;&#34;helper function to create new pages within Confluence&#34;&#34;&#34;
        if parent == None:
            parent = getSpaceHomepageID( spaceKey )

        createUrl    = &#39;{url}rest/api/content&#39;.format( url=self.app[ &#39;url&#39; ] )
        createObject = {
            &#34;type&#34;: &#34;page&#34;,
            &#34;title&#34;: title,
            &#34;space&#34;: {
                &#34;key&#34;: spaceKey
            },
            &#34;body&#34;: {
                &#34;storage&#34;: {
                    &#34;value&#34;: contentHtml,
                    &#34;representation&#34;: &#34;storage&#34;
                }
            },
            &#34;ancestors&#34;: [{
                &#34;id&#34;: parent
            }]
        }

        response = self.sessionPostRequest( createUrl, createObject, session )
        rc = response.status_code

        i = 1
        title = createObject[ &#39;title&#39; ]

        while rc != 200 and &#39;already exists&#39; in response.json()[&#39;message&#39;].lower():
            print( &#39;    &#39; + response.json()[&#39;message&#39;] )
            createObject[ &#39;title&#39; ] = &#39;{} ({})&#39;.format( title, i )
            response = self.sessionPostRequest( createUrl, createObject, session )
            rc = response.status_code
            i += 1

        if rc == 200:
            return [ response.json()[&#39;id&#39;], createObject[ &#39;title&#39; ] ]
        else:
            raise Exception ( &#34;API Response ({}) was:\n\n{}&#34;.format( rc, response.content ) )

    def updatePage( self, newTitle, contentHtml, pageID, spaceKey, version=None, session=None ):
        &#34;&#34;&#34;helper function to update a pages content&#34;&#34;&#34;
        if version == None:
            version = self.getPageInfoByID( pageID )[ &#39;version&#39; ][ &#39;number&#39; ] + 1

        createObject = {
            &#34;id&#34;: pageID,
            &#34;type&#34;: &#34;page&#34;,
            &#34;title&#34;: newTitle,
            &#34;space&#34;: {
                &#34;key&#34;: spaceKey
            },
            &#34;body&#34;: {
                &#34;storage&#34;: {
                    &#34;value&#34;: contentHtml,
                    &#34;representation&#34;: &#34;storage&#34;
                }
            },
            &#34;version&#34;: {
                &#34;number&#34;: version
            }
        }

        createUrl = &#39;{url}rest/api/content/{pid}&#39;.format( url=self.app[ &#39;url&#39; ], pid=pageID )
        response  = self.sessionPutRequest( createUrl, createObject, session=session )
        rc = response.status_code

        if rc == 200:
            return response.json()[&#39;id&#39;]
        else:
            raise Exception ( &#34;API Response ({}) was:\n\n{}&#34;.format( rc, response.content ) )

    def getPageContent( self, pageID, session=None ):
        &#34;&#34;&#34;helper function to retrieve content of page by pageID&#34;&#34;&#34;
        apiUrl = &#39;{url}rest/api/content/{pid}?expand=body.storage&#39;.format( url=self.app[ &#39;url&#39; ], pid=pid )
        if session == None:
            session = self.toSession( curl = True )
        rspC = session.get( apiUrl )
        if rspC.status_code == 200:
            rsp = json.loads( rspC.text )
            return rsp[ &#39;body&#39; ][ &#39;storage&#39; ][ &#39;value&#39; ]
        else:
            return None


    def deletePage( self, pageID, session=None ):
        &#34;&#34;&#34;helper function to delete a given page&#34;&#34;&#34;
        if session == None:
            session = self.toSession( curl = True )
        rsp = session.delete( &#39;{url}rest/api/content/{id}&#39;.format( url=self.app[ &#39;url&#39; ], id=pageID ) )
        return rsp

    def getGroups( self ):
        &#34;&#34;&#34;Retrieve Confluence local groups&#34;&#34;&#34;
        cgroups = []
        session = self.toSession()
        stop = False
        i = 0
        while True:
            limit = 1000
            rspC = session.get(&#39;{url}rest/api/group?start={start}&amp;limit={limit}&#39;.format( url=self.app[ &#39;url&#39; ], limit=limit, start=( i * limit ) ) )
            if rspC.status_code == 200:
                rsp = json.loads( rspC.text )
                for g in rsp[&#39;results&#39;]:
                    cgroups.append( g[&#39;name&#39;] )
            else:
                stop = True

            if stop or len( rsp[&#39;results&#39;] ) == 0:
                break
            else:
                i += 1
        return cgroups

    def webSudo( self, adjustCookies = True ):
        &#34;&#34;&#34;run Confluence websudo&#34;&#34;&#34;
        authUrl    = &#39;{url}authenticate.action&#39;.format( url=self.app[ &#39;url&#39; ] )
        sysInfoUrl = &#39;{url}admin/viewgeneralconfig.action&#39;.format( url=self.app[ &#39;url&#39; ] )
        super( Confluence, self ).webSudo( authUrl, sysInfoUrl, adjustCookies )

    def getSpaceKeys( self, force = False, personalSpaces = False ):
        &#34;&#34;&#34;get all space keys of Confluence spaces through API&#34;&#34;&#34;
        # self.webSudo()
        session = self.toSession( curl=True )
        if force or self.spaceKeys == []:
            self.spaceKeys = []
            stop = False
            i = 0
            users = []
            while True:
                limit = 50
                start = i * limit
                apiUrl = &#39;{url}rest/api/space?start={start}&amp;limit={limit}&#39;.format( url=self.app[ &#39;url&#39; ], start=start, limit=limit )
                rspJ = session.get( apiUrl )
                if rspJ.status_code == 200:
                    rsp = json.loads( rspJ.text )
                    if rsp[ &#39;size&#39; ] &lt; limit:
                        stop = True
                    for k in rsp[ &#39;results&#39; ]:
                        if personalSpaces or k[ &#39;type&#39; ] not in [ &#39;personal&#39; ]:
                            self.spaceKeys.append( k[ &#39;key&#39; ] )
                else:
                    print(&#39;start: {s}, limit: {l}, rc: {r}&#39;.format( s=start, l=limit, r=str(rspJ.status_code) ) )
                    stop = True
                if stop or len( rsp[&#39;results&#39;] ) == 0:
                    break
                else:
                    i += 1
        return self.spaceKeys

    def getSpaceKeysGUI( self, force=False ):
        &#34;&#34;&#34;get all space keys of Confluence spaces through GUI&#34;&#34;&#34;
        if force or self.spaceKeys == []:
            self.spaceKeys = []
            self.get( self.app[ &#39;url&#39; ] + &#39;spacedirectory/view.action&#39; )
            while True:
                soup = self.toSoup()
                self.spaceKeys += [ item[ &#39;data-spacekey&#39; ] for item in soup.select( &#39;tbody tr&#39; ) ]
                try:
                    nextBtn = soup.select( &#39;.aui-nav-next a&#39; )[0]
                    check   = nextBtn[ &#39;href&#39; ]
                    self.browser.find_element( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, normalize-space(@class), &#34; &#34;), &#34; aui-nav-next &#34;)]//a&#39; ).click()
                    time.sleep( 5 )
                except:
                    break
        return self.spaceKeys

    def APIFileRequest( self, url, mime, filename, filecontent, transferCookies = False ):
        &#34;&#34;&#34;send a file through POST request into space&#34;&#34;&#34;
        session = self.toSession( curl=True )
        attachData = {
            &#34;bodyType&#34;: &#34;storage&#34;,
            &#34;supportedContainerTypes&#34;: [
                &#34;space&#34;,
                &#34;page&#34;
            ],
                &#34;supportedChildTypes&#34;: [
                &#34;attachment&#34;,
                &#34;comment&#34;
            ],
            &#34;supportedSpacePermissions&#34;: [],
            &#34;preventDuplicateTitle&#34;: False,
            &#34;indexing&#34;: {
                &#34;enabled&#34;: True
            },
            &#34;files&#34;: {
                &#39;file&#39;: ( filename, filecontent, mime )
            }
        }

        request = session.post( url, data = attachData, headers = { &#34;Content-Type&#34;: &#34;multipart/form-data&#34;, &#34;X-Atlassian-Token&#34;: &#34;no-check&#34; } )
        if transferCookies:
            # write Cookies from POST request to Selenium Browser
            new_cookies = session.cookies.get_dict()
            self.browser.get( request.url )
            for key, value in new_cookies.items():
                self.browser.add_cookie( { &#34;name&#34;: key, &#34;value&#34;: value } )
            self.get( request.url )
        return request

    def cleanupPermissions( self ):
        &#34;&#34;&#34;function to clean up permissions in spaces&#34;&#34;&#34;
        editPermissionUrl = self.app[ &#39;url&#39; ] + &#39;spaces/editspacepermissions.action?edit=Edit+Permissions&amp;key=&#39;
        userCheckApiUrl   = self.app[ &#39;url&#39; ] + &#39;rest/api/user?username=&#39;
        admingroupname    = os.getenv( &#39;CONFLUENCE_ADMIN_GROUP&#39;, &#39;confluence-administrators&#39; )
        self.getSpaceKeys()
        session = self.toSession()
        resp = session.get( userCheckApiUrl + self.app[ &#39;user&#39; ] )
        if resp.status_code == 403:
            self.login()
            self.webSudo()
            session = self.toSession()
        for space in self.spaceKeys:
            self.get( editPermissionUrl + space )
            rows         = self.browser.find_elements( By.XPATH, &#39;//*[@id=&#34;uPermissionsTable&#34;]//tr&#39;)[2:]
            removedUsers = []
            for row in rows:
                username   = row.find_element( By.XPATH,&#39;.//span&#39;).text[1:-1]
                userApiUrl = userCheckApiUrl + username
                resp       = session.get( userApiUrl )
                if resp.status_code == 200:
                    # User exists, all fine
                    pass
                elif resp.status_code == 404:
                    removedUsers += [ username ]
                    row.find_element( By.XPATH,&#39;.//td[1]//button&#39;).click()
                    # User does not exist, remove all permissions
                else:
                    raise APIError( resp.status_code, userApiUrl )
            time.sleep(4)
            self.browser.find_element( By.XPATH,&#39;//input[@name=&#34;save&#34; and @type=&#34;submit&#34;]&#39;).click()
            time.sleep(2)
            self.get( editPermissionUrl + space )
            rows = self.browser.find_elements( By.XPATH, &#39;//*[@id=&#34;uPermissionsTable&#34;]//tr&#39;)[2:]
            for row in rows:
                username   = row.find_element( By.XPATH,&#39;.//span&#39;).text[1:-1]
                if username in removedUsers:
                    row.find_element( By.XPATH,&#39;.//td[1]//button&#39;).click()
            self.browser.find_element( By.XPATH,&#39;//input[@name=&#34;save&#34; and @type=&#34;submit&#34;]&#39;).click()
            time.sleep(2)
            self.get( editPermissionUrl + space )
            rows = self.browser.find_elements( By.XPATH, &#39;//*[@id=&#34;uPermissionsTable&#34;]//tr&#39;)[2:]
            admins_added = False
            for row in rows:
                username   = row.find_element( By.XPATH,&#39;.//span&#39;).text[1:-1]
                if username in removedUsers:
                    if not admins_added:
                        groupaddfield = self.browser.find_element( By.ID,&#39;groups-to-add-autocomplete&#39;)
                        groupaddfield.send_keys( Keys.CONTROL, &#34;a&#34; )
                        groupaddfield.send_keys( admingroupname )
                        self.browser.find_element( By.XPATH, &#39;//*[@name=&#34;groupsToAddButton&#34; and @type=&#34;submit&#34;]&#39; ).click()
                        time.sleep(2)
                        self.browser.find_element( By.XPATH, &#39;//*[@id=&#34;gPermissionsTable&#34;]//*[contains(text(), &#34;&#39; + admingroupname + &#39;&#34;)]//button&#39; ).click()
                        admins_added = True
                        break
            if admins_added:
                rows = self.browser.find_elements( By.XPATH, &#39;//*[@id=&#34;uPermissionsTable&#34;]//tr&#39;)[2:]
                for row in rows:
                    username   = row.find_element( By.XPATH,&#39;.//span&#39;).text[1:-1]
                    if username in removedUsers:
                        row.find_element( By.XPATH,&#39;.//td[1]//button&#39;).click()
            self.browser.find_element( By.XPATH,&#39;//input[@name=&#34;save&#34; and @type=&#34;submit&#34;]&#39;).click()
            time.sleep(2)

    def getPermissionRepresentation( self, boolList, trueVal=&#39;X&#39;, falseVal=&#39;-&#39; ):
        &#34;&#34;&#34;generate a simple representation of a permission row for Confluence space&#34;&#34;&#34;
        rep = &#39;&#39;
        for x in boolList:
            if x:
                rep += trueVal
            else:
                rep += falseVal
        return rep

    def getBoolListFromRepresentation( self, representation, trueVal=&#39;X&#39;, falseVal=&#39;-&#39; ):
        &#34;&#34;&#34;revert representation of a permission row for Confluence space to boolean list&#34;&#34;&#34;
        boolList = []
        for c in representation:
            if c == trueVal:
                boolList.append( True )
            elif c == falseVal:
                boolList.append( False )
            else:
                raise Exception( &#39;Check your representation – trueVal (\&#39;{trueVal}\&#39;) and falseVal (\&#39;{falseVal}\&#39;) are not matched by \&#39;{val}\&#39;!&#39;.format( trueVal=trueVal, falseVal=falseVal, val=c ) )
        return boolList

    def getAllSpacePermissions( self, force=False, debug=True ):
        &#34;&#34;&#34;function to retrieve all space permissions in Confluence&#34;&#34;&#34;
        if force or self.permissions == {}:
            self.permissions = {}
            self.getSpaceKeys()
            for space in self.spaceKeys:
                self.permissions[ space ] = self.getSpacePermissions( space )
        return self.permissions

    def getSpacePermissions( self, spaceKey, force=False, debug=False ):
        &#34;&#34;&#34;function to retrieve space permissions for one Confluence space specified through Space Key&#34;&#34;&#34;
        if force or spaceKey not in self.permissions:
            permissionUrl = &#39;{url}spaces/spacepermissions.action?key={space}&#39;.format( url=self.app[ &#39;url&#39; ], space=spaceKey )
            if debug:
                print( spaceKey )
            self.get( permissionUrl )
            soup = self.toSoup()
            if self.permissionsNames == []:
                mainPerms = [ item.text for item in soup.select(&#39;table.permissions tr:first-of-type&#39;)[0].find_all(&#39;th&#39;)[1:] ]
                i = 0
                for item in soup.select(&#39;table.permissions tr:nth-of-type(2)&#39;)[0].find_all(&#39;th&#39;)[1:]:
                    try:
                        if &#39;permissions-group-start&#39; in item[ &#39;class&#39; ]:
                            i += 1
                    except:
                        pass
                    self.permissionsNames += [ mainPerms[ i ] + &#39; (&#39; + item.text + &#39;)&#39; ]
            tempPermissions = {}
            anonymous = soup.select(&#39;#aPermissionsTable tr:not(:first-of-type):not(:nth-of-type(2))&#39;)[0].select( &#39;td&#39; )
            tempPermissions[ &#39;ANONYMOUS&#39; ] = { &#39;anonymous&#39;: self.fetchPermissionsFromRow( anonymous[1:] ) }
            users     = soup.select(&#39;#uPermissionsTable tr:not(:first-of-type):not(:nth-of-type(2))&#39;)
            tempPermissions[ &#39;USERS&#39; ] = {}
            for row in users:
                tds = row.select( &#39;td&#39; )
                tempPermissions[ &#39;USERS&#39; ][ tds[0].select( &#39;span&#39; )[0].text.strip()[1:-1] ] = self.fetchPermissionsFromRow( tds[1:] )
            groups    = soup.select(&#39;#gPermissionsTable tr:not(:first-of-type):not(:nth-of-type(2))&#39;)
            tempPermissions[ &#39;GROUPS&#39; ] = {}
            for row in groups:
                tds = row.select( &#39;td&#39; )
                tempPermissions[ &#39;GROUPS&#39; ][ tds[0].text.strip() ] = self.fetchPermissionsFromRow( tds[1:] )
            return tempPermissions
        else:
            return self.permissions[ spaceKey ]

    def fetchPermissionsFromRow( self, row ):
        &#34;&#34;&#34;helper function to fetch permissions from one table row in permission view of Confluence space&#34;&#34;&#34;
        return [ item[ &#39;data-permission-set&#39; ].lower() != &#39;false&#39; for item in row ]

    def getGroupMembers( self, group ):
        &#34;&#34;&#34;Retrieve group member usernames from Confluence&#34;&#34;&#34;
        sessionC = self.toSession()
        stop = False
        i = 0
        users = []
        limit = 50
        firstRun = True
        while True:
            parameters = {
                &#39;start&#39;: ( i * limit ),
                &#39;limit&#39;: limit,
            }
            memberUrl = &#39;{url}rest/api/group/{group}/member?{params}&#39;.format( url=self.app[ &#39;url&#39; ], group=group, params=urllib.parse.urlencode( parameters ) )
            rspC = sessionC.get( memberUrl )

            if rspC.status_code == 200:
                rsp = json.loads( rspC.text )
                if firstRun and ( rsp[ &#39;size&#39; ] &lt; rsp[ &#39;limit&#39; ] or limit != rsp[ &#39;limit&#39; ] ):
                    limit = rsp[ &#39;size&#39; ]
                elif rsp[ &#39;size&#39; ] &lt; limit:
                    stop = True
                for u in rsp[&#39;results&#39;]:
                    users.append( u[ &#39;username&#39; ] )
            else:
                print(&#39;rc: &#39; + str(rspC.status_code))
                print(parameters)
                stop = True

            if stop or len( rsp[&#39;results&#39;] ) == 0:
                len( rsp[&#39;results&#39;] )
                break
            else:
                i += 1
            firstRun = False
        return users

    def getUserApiInfo( self, username, returnResponse=False, session=None ):
        &#34;&#34;&#34;Function to gather information about a user from API – if `returnResponse` is True, the whole request response is returned, otherwise only the decoded answer object&#34;&#34;&#34;
        apiUrl = &#39;{url}rest/mobile/latest/profile/{user}&#39;.format( url=self.app[&#39;url&#39;], user=urllib.parse.quote( username ) )
        return self.apiGetInfo( apiUrl, returnResponse, session )

    def recoverConfluencePermissions( self ):
        &#34;&#34;&#34;Function to recover confluence permissions if a system administrator has no space access. ENSURE YOUR SYSTEM LANGUAGE TO BE ENGLISH!&#34;&#34;&#34;
        permsurl = &#39;{url}/admin/permissions/viewdefaultspacepermissions.action&#39;.format( url=self.app[&#39;url&#39;] )
        self.browser.get( permsurl )
        xpath = &#39;//a[text()=&#34;Recover Permissions&#34;]&#39;
        xpathOk = &#39;//button[text()=&#34;OK&#34;]&#39;
        okJS = &#39;xPathRes = document.evaluate (\&#39;{xpath}\&#39;, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null); xPathRes.singleNodeValue.click();&#39;.format( xpath=xpathOk )
        listOfSpaces = []
        try:
            element = self.browser.find_element( By.XPATH, xpath )
            element.location_once_scrolled_into_view
        except:
            element = False
        while element:
            listOfSpaces += [ element.get_attribute( &#39;data-space-key&#39; ) ]
            element.click()
            WebDriverWait( self.browser, 10 ).until( EC.presence_of_element_located( ( By.XPATH, xpathOk ) ) )
            self.browser.execute_script( okJS )
            WebDriverWait( self.browser, 10 ).until_not( EC.presence_of_element_located( ( By.ID, &#39;recover-permissions-dialog&#39; ) ) )
            time.sleep( 0.5 )
            try:
                element = self.browser.find_element( By.XPATH, xpath )
                element.location_once_scrolled_into_view
            except:
                element = False
        return listOfSpaces

    def getAllSpacePermissionsAsRepresentation( self, force=False, debug=True, trueVal=&#39;X&#39;, falseVal=&#39;-&#39; ):
        &#34;&#34;&#34;
        Function to retrieve dictionary of permission representations.
        First level keys are space keys followed by second key as (like in getAllSpacePermissions) categories `GROUPS`, `USERS` and `ANONYMOUS`.
        The last key-level of the result dictionary is the granted object identifier (group name, user name or `anonymous`) followed by the representation.
        &#34;&#34;&#34;
        perms = self.getAllSpacePermissions( force, debug )
        vperms = {}
        for spacekey, permissions in perms.items():
            vperms[ spacekey ] = {}
            for category, specificperms in permissions.items():
                vperms[ spacekey ][ category ] = {}
                for key, permarray in specificperms.items():
                    vperms[ spacekey ][ category ][ key ] = self.getPermissionRepresentation( permarray, trueVal, falseVal )
        return vperms

    def addNewSpacePermissions( self, spaceKey, category, objectName, representation, isRepresentation=True, submitChanges=True ):
        &#34;&#34;&#34;Function to add new space permissions – if `isRepresentation` is `False`, a boolean list for permissions is expected.&#34;&#34;&#34;
        self.callPermissionChangePage( spaceKey )
        if category == &#39;GROUPS&#39;:
            gfield = self.browser.find_element_by_xpath( &#39;//input[@name=&#34;groupsToAdd&#34;]&#39; )
            gfield.send_keys( Keys.CONTROL, &#34;a&#34; )
            gfield.send_keys( objectName )
            time.sleep(1)
            self.browser.find_element( By.XPATH, &#39;//input[@name=&#34;groupsToAddButton&#34;]&#39; ).click()
        elif category == &#39;USERS&#39;:
            gfield = self.browser.find_element_by_xpath( &#39;//input[@name=&#34;usersToAdd&#34;]&#39; )
            gfield.send_keys( Keys.CONTROL, &#34;a&#34; )
            gfield.send_keys( objectName )
            time.sleep(1)
            self.browser.find_element( By.XPATH, &#39;//input[@name=&#34;usersToAddButton&#34;]&#39; ).click()
        elif category == &#39;ANONYMOUS&#39;:
            # ANONYMOUS has only one row which is always present
            pass
        else:
            raise Exception( &#39;{val} is an invalid category!&#39;.format( val=category ) )
        time.sleep(1)
        self.adjustSpacePermissions( spaceKey, category, objectName, representation, isRepresentation, submitChanges )

    def adjustSpacePermissions( self, spaceKey, category, objectName, representation, isRepresentation=True, submitChanges=True ):
        &#34;&#34;&#34;Function to change existing space permissions – if `isRepresentation` is `False`, a boolean list for permissions is expected.&#34;&#34;&#34;
        self.callPermissionChangePage( spaceKey )
        if isRepresentation:
            representation = self.getBoolListFromRepresentation( representation )
        try:
            permissionCheckboxes = self.selectObjectRowForSpacePermissionChange( category, objectName, spaceKey )
            if os.getenv( &#34;PRINT_DEBUG_INFO&#34;, &#34;False&#34; ).lower() in [ &#34;1&#34;, &#34;true&#34;, &#34;t&#34;, &#34;y&#34;, &#34;yes&#34; ]:
                rc  = len( representation )
                pcc = len( permissionCheckboxes )
                if rc != pcc:
                    print( &#39;Representation length ({rc}) and permission checkboxes lenght ({pcc}) do not match! Values are mapped as far as possible.&#39;.format( rc=rc, pcc=pcc ) )
                    print()
            for i, granted in enumerate( representation ):
                try:
                    element = permissionCheckboxes[ i ].find_element( By.XPATH, &#39;.//input[@type=&#34;checkbox&#34;]&#39; )
                    while element.is_selected() != granted:
                        element.click()
                except:
                    pass
            if submitChanges:
                self.submitSpacePermissionChange()
        except:
            if os.getenv( &#34;PRINT_DEBUG_INFO&#34;, &#34;False&#34; ).lower() in [ &#34;1&#34;, &#34;true&#34;, &#34;t&#34;, &#34;y&#34;, &#34;yes&#34; ]:
                print( &#39;Object {obj} in category {cat} could not be found for space with key {sk} ...&#39;.format( obj=objectName, cat=category, sk=spaceKey ) )

    def removeSpacePermissions( self, spaceKey, category, objectName, submitChanges=True ):
        &#34;&#34;&#34;Function to remove permissions from space&#34;&#34;&#34;
        self.callPermissionChangePage( spaceKey )
        try:
            permissionCheckboxes = self.selectObjectRowForSpacePermissionChange( category, objectName, spaceKey )
            for element in permissionCheckboxes:
                checkbox = element.find_element( By.XPATH, &#39;.//input[@type=&#34;checkbox&#34;]&#39; )
                while checkbox.is_selected():
                    checkbox.click()
            if submitChanges:
                self.submitSpacePermissionChange()
        except:
            if os.getenv( &#34;PRINT_DEBUG_INFO&#34;, &#34;False&#34; ).lower() in [ &#34;1&#34;, &#34;true&#34;, &#34;t&#34;, &#34;y&#34;, &#34;yes&#34; ]:
                print( &#39;Object {obj} in category {cat} could not be found for space with key {sk} ...&#39;.format( obj=objectName, cat=category, sk=spaceKey ) )

    def selectObjectRowForSpacePermissionChange( self, category, objectName, spaceKey ):
        &#34;&#34;&#34;Helper function to select the correct row for changing permissions&#34;&#34;&#34;
        xpathPermissionCell = &#39;.//*[contains(concat(&#34; &#34;, normalize-space(@class), &#34; &#34;), &#34; permissionCell &#34;)]&#39;
        if category == &#39;GROUPS&#39;:
            permissionRow = self.browser.find_element( By.XPATH, &#39;//td[@data-permission-group=\&#39;{obj}\&#39;][1]/parent::tr&#39;.format( obj=objectName ) )
        elif category == &#39;USERS&#39;:
            permissionRow = self.browser.find_element( By.XPATH, &#39;//td[@data-permission-user=\&#39;{obj}\&#39;][1]/parent::tr&#39;.format( obj=objectName ) )
        elif category == &#39;ANONYMOUS&#39;:
            permissionRow = self.browser.find_element( By.ID, &#39;aPermissionsTable&#39; )
            permissionRow = permissionRow.find_element( By.XPATH, &#39;{xpath}[1]/parent::tr&#39;.format( xpath=xpathPermissionCell) )
        else:
            raise Exception( &#39;{val} is an invalid category!&#39;.format( val=category ) )
        permissionCheckboxes = permissionRow.find_elements( By.XPATH, xpathPermissionCell )
        pcc = len( permissionCheckboxes )
        if pcc != 14:
            raise Exception( &#39;There are {c} permission checkboxes found for object {obj} in space permissions for space with key {sk}! (14 expected ...)&#39;.format( c=pcc, obj=objectName, sk=spaceKey ) )
        return permissionCheckboxes

    def callPermissionChangePage( self, spaceKey ):
        &#34;&#34;&#34;Helper function to call permission change page for a specified Confluence space&#34;&#34;&#34;
        url = &#39;{url}spaces/editspacepermissions.action?key={space}&#39;.format( url=self.app[&#39;url&#39;], space=spaceKey )
        if self.browser.current_url != url:
            self.webSudo()
            self.get( url )

    def submitSpacePermissionChange( self ):
        &#34;&#34;&#34;Submit the permission changes on space permission change page of confluence&#34;&#34;&#34;
        time.sleep(1)
        self.browser.find_element( By.XPATH, &#39;//input[@name=&#34;save&#34;]&#39; ).click()

    def setSpacePermissions( self, spaceKey, representationDictionary, forceRefresh=False ):
        &#34;&#34;&#34;Function meant to adjust space permissions to match a representation dictionary like returned by `getAllSpacePermissionsAsRepresentation`.&#34;&#34;&#34;
        currentPermissions = self.getSpacePermissions( spaceKey, forceRefresh )
        for category in representationDictionary:
            for objectName, newPermissions in representationDictionary[ category ].items():
                if objectName not in currentPermissions[ category ]:
                    self.addNewSpacePermissions( spaceKey, category, objectName, newPermissions, submitChanges=False )
                else:
                    self.adjustSpacePermissions( spaceKey, category, objectName, newPermissions, submitChanges=False )
        # removing permissions has to be the last step since it could be that space permissions then lock out the current user
        for category in representationDictionary:
            for objectName in currentPermissions[ category ]:
                if objectName not in representationDictionary[ category ]:
                    self.removeSpacePermissions( spaceKey, category, objectName, submitChanges=False )
        self.submitSpacePermissionChange()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Atlassian.Atlassian"><code class="flex name class">
<span>class <span class="ident">Atlassian</span></span>
</code></dt>
<dd>
<div class="desc"><p>Special functions for Atlassian systems – they need to have <code>nosso</code> active at least &hellip;</p>
<p>function to initiate the systems as needed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Atlassian ( Browser ):
    &#34;&#34;&#34;Special functions for Atlassian systems – they need to have `nosso` active at least ...&#34;&#34;&#34;

    def webSudo( self, authUrl, sysInfoUrl, adjustCookies = True ):
        &#34;&#34;&#34;run the application webSudo&#34;&#34;&#34;
        if not self.checkLogin():
            self.login()
        self.browser.get( sysInfoUrl )
        pwFieldXPath = &#39;//input[@type=&#34;password&#34;]&#39;
        doWebSudo = (
                        self.browser.current_url != sysInfoUrl
                    ) or (
                        self.checkElementByXpath( pwFieldXPath )
                    )
        if doWebSudo:
            self.browser.get( authUrl )
            pwfield = WebDriverWait( self.browser, 10 ).until( EC.presence_of_element_located( ( By.XPATH, pwFieldXPath ) ) )
            pwfield.send_keys( Keys.CONTROL, &#34;a&#34; )
            pwfield.send_keys( self.app[ &#39;passwd&#39; ] )
            pwfield.send_keys( Keys.ENTER )
            time.sleep( 5 )
            if adjustCookies:
                self.refresh()

    def getToken( self ):
        &#34;&#34;&#34;get CSRF token of Atlassian App&#34;&#34;&#34;
        self.get( self.app[&#39;url&#39;] )
        return self.browser.find_element( By.ID, &#39;atlassian-token&#39; ).get_attribute( &#39;content&#39; )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>macwinnie_pyhelpers.Browser.Browser</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="Atlassian.Confluence" href="#Atlassian.Confluence">Confluence</a></li>
<li><a title="Atlassian.Jira" href="#Atlassian.Jira">Jira</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="Atlassian.Atlassian.getToken"><code class="name flex">
<span>def <span class="ident">getToken</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get CSRF token of Atlassian App</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getToken( self ):
    &#34;&#34;&#34;get CSRF token of Atlassian App&#34;&#34;&#34;
    self.get( self.app[&#39;url&#39;] )
    return self.browser.find_element( By.ID, &#39;atlassian-token&#39; ).get_attribute( &#39;content&#39; )</code></pre>
</details>
</dd>
<dt id="Atlassian.Atlassian.webSudo"><code class="name flex">
<span>def <span class="ident">webSudo</span></span>(<span>self, authUrl, sysInfoUrl, adjustCookies=True)</span>
</code></dt>
<dd>
<div class="desc"><p>run the application webSudo</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def webSudo( self, authUrl, sysInfoUrl, adjustCookies = True ):
    &#34;&#34;&#34;run the application webSudo&#34;&#34;&#34;
    if not self.checkLogin():
        self.login()
    self.browser.get( sysInfoUrl )
    pwFieldXPath = &#39;//input[@type=&#34;password&#34;]&#39;
    doWebSudo = (
                    self.browser.current_url != sysInfoUrl
                ) or (
                    self.checkElementByXpath( pwFieldXPath )
                )
    if doWebSudo:
        self.browser.get( authUrl )
        pwfield = WebDriverWait( self.browser, 10 ).until( EC.presence_of_element_located( ( By.XPATH, pwFieldXPath ) ) )
        pwfield.send_keys( Keys.CONTROL, &#34;a&#34; )
        pwfield.send_keys( self.app[ &#39;passwd&#39; ] )
        pwfield.send_keys( Keys.ENTER )
        time.sleep( 5 )
        if adjustCookies:
            self.refresh()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Atlassian.Confluence"><code class="flex name class">
<span>class <span class="ident">Confluence</span></span>
</code></dt>
<dd>
<div class="desc"><p>Confluence Browser – recommended to use administrative user; otherwise most functions won't work properly</p>
<p>function to initiate the systems as needed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Confluence ( Atlassian ):
    &#34;&#34;&#34;Confluence Browser – recommended to use administrative user; otherwise most functions won&#39;t work properly&#34;&#34;&#34;

    spaceKeys        = []
    spaceNames       = {}
    permissions      = {}
    permissionsNames = []
    appInfo = {
        &#34;url&#34;:    {
            &#34;env&#34;:         &#34;CONFLUENCE_URL&#34;,
            &#34;url&#34;:         True,
            &#34;description&#34;: &#34;Enter Confluence URL&#34;,
        },
        &#34;user&#34;:   {
            &#34;env&#34;:         &#34;CONFLUENCE_USER&#34;,
            &#34;description&#34;: &#34;Enter Confluence username&#34;,
        },
        &#34;passwd&#34;: {
            &#34;password&#34;:    True,
            &#34;env&#34;:         &#34;CONFLUENCE_PASS&#34;,
            &#34;description&#34;: &#34;Enter Confluence password&#34;,
        },
    }

    def __init__( self ):
        super( Confluence, self ).__init__()

    def login( self, skipSSO=True ):
        &#34;&#34;&#34;Run Confluence login&#34;&#34;&#34;
        loginUrl = self.app[ &#39;url&#39; ] + &#34;dologin.action&#34;
        if skipSSO:
            loginUrl += &#39;?nosso&#39;
        self.loadCookies( url=loginUrl )
        self.setSessionBaseHeaders()
        userObject = { &#34;os_username&#34;: self.app[ &#39;user&#39; ], &#34;os_password&#34;: self.app[ &#39;passwd&#39; ], &#34;os_cookie&#34;: &#34;true&#34;, &#34;login&#34;: &#34;Log in&#34;, &#34;os_destination&#34;: &#34;&#34;, }
        if os.getenv( &#34;PRINT_DEBUG_INFO&#34;, &#34;False&#34; ).lower() in [ &#34;1&#34;, &#34;true&#34;, &#34;t&#34;, &#34;y&#34;, &#34;yes&#34; ]:
            print( &#39;User is being logged in with those credentials:&#39; )
            print( userObject )
            print()
        self.sessionPostRequest( loginUrl, userObject, True, urlOverride=True )
        self.get( self.app[ &#39;url&#39; ] , False )

    def checkLogin( self ):
        &#34;&#34;&#34;Check if login is needed&#34;&#34;&#34;
        currentUrl = self.browser.current_url
        urlLen     = len( self.app[ &#39;url&#39; ] )
        if currentUrl[ 0:urlLen ] != self.app[ &#39;url&#39; ]:
            self.get( self.app[ &#39;url&#39; ], False )
        try:
            self.browser.find_element( By.ID, &#39;loginButton&#39; )
            return False
        except:
            return True

    def setSessionBaseHeaders( self, api=False ):
        &#34;&#34;&#34;Api requests need special headers in Confluence ... sometimes ...&#34;&#34;&#34;
        if not api:
            self.sessionBaseHeaders = None
        else:
            self.sessionBaseHeaders = {
                &#34;Content-Type&#34;:      &#34;application/json&#34;,
                &#34;X-Atlassian-Token&#34;: &#34;no-check&#34;
            }

    def getPageInfo( self, spaceKey, title, session=None ):
        &#34;&#34;&#34;Function to get page information by Confluence space key and page title&#34;&#34;&#34;
        self.setSessionBaseHeaders( api=True )
        parameters = {
            &#39;spaceKey&#39;: spaceKey,
            &#39;title&#39;:    title,
            &#39;expand&#39;:   &#39;version,space&#39;,
        }
        apiUrl  = &#39;{url}rest/api/content?{params}&#39;.format( url=self.app[ &#39;url&#39; ], params=urllib.parse.urlencode( parameters ) )
        results = self.apiGetInfo( apiUrl, session=session )
        if results[ &#39;size&#39; ] &gt; 1:
            raise Exception( &#39;More than one page found – cannot proceed properly ...&#39; )
        return results[ &#39;results&#39; ][ 0 ]

    def getPageInfoByID( self, pageID, session=None ):
        &#34;&#34;&#34;Function to get page information by page ID&#34;&#34;&#34;
        self.setSessionBaseHeaders( api=True )
        parameters = {
            &#39;expand&#39;:   &#39;version,space&#39;,
        }
        apiUrl = &#39;{url}rest/api/content/{id}?{params}&#39;.format( url=self.app[ &#39;url&#39; ], id=pageID, params=urllib.parse.urlencode( parameters ) )
        result = self.apiGetInfo( apiUrl, session=session )
        return result

    def getSpaceName( self, spaceKey, session=None ):
        &#34;&#34;&#34;Helper function to retrieve the space name of a Confluence Space&#34;&#34;&#34;
        self.setSessionBaseHeaders( api=True )
        apiUrl = &#39;{url}rest/api/space/{spaceKey}&#39;.format( url=self.app[ &#39;url&#39; ], spaceKey=spaceKey )
        result = self.apiGetInfo( apiUrl, session=session )
        if result != None:
            return result[ &#39;name&#39; ]

    def getSpaceKeyFromName( self, spaceName, force=False, session=None ):
        &#34;&#34;&#34;Helper function to retrieve space key by space name&#34;&#34;&#34;
        if len( self.spaceNames ) == 0 or force == True:
            sks = self.getSpaceKeys()
            for sk in sks:
                self.spaceNames[ self.getSpaceName( sk ) ] = sk
        if spaceName in self.spaceNames:
            return self.spaceNames[ spaceName ]

    def getSpaceHomepageID( self, spaceKey, session=None ):
        &#34;&#34;&#34;Helper function to get page ID of homepage of Space&#34;&#34;&#34;
        self.setSessionBaseHeaders( api=True )
        parameters = {
            &#39;expand&#39;:   &#39;homepage&#39;,
            &#39;spaceKey&#39;: spaceKey,
        }
        apiUrl = &#39;{url}rest/api/space?{params}&#39;.format( url=self.app[ &#39;url&#39; ], id=pageID, params=urllib.parse.urlencode( parameters ) )
        result = self.apiGetInfo( apiUrl, session=session )
        if result != None:
            return result[ &#39;results&#39; ][ 0 ][ &#39;homepage&#39; ][ &#39;id&#39; ]

    def createPage( self, title, contentHtml, spaceKey, parent=None, session=None ):
        &#34;&#34;&#34;helper function to create new pages within Confluence&#34;&#34;&#34;
        if parent == None:
            parent = getSpaceHomepageID( spaceKey )

        createUrl    = &#39;{url}rest/api/content&#39;.format( url=self.app[ &#39;url&#39; ] )
        createObject = {
            &#34;type&#34;: &#34;page&#34;,
            &#34;title&#34;: title,
            &#34;space&#34;: {
                &#34;key&#34;: spaceKey
            },
            &#34;body&#34;: {
                &#34;storage&#34;: {
                    &#34;value&#34;: contentHtml,
                    &#34;representation&#34;: &#34;storage&#34;
                }
            },
            &#34;ancestors&#34;: [{
                &#34;id&#34;: parent
            }]
        }

        response = self.sessionPostRequest( createUrl, createObject, session )
        rc = response.status_code

        i = 1
        title = createObject[ &#39;title&#39; ]

        while rc != 200 and &#39;already exists&#39; in response.json()[&#39;message&#39;].lower():
            print( &#39;    &#39; + response.json()[&#39;message&#39;] )
            createObject[ &#39;title&#39; ] = &#39;{} ({})&#39;.format( title, i )
            response = self.sessionPostRequest( createUrl, createObject, session )
            rc = response.status_code
            i += 1

        if rc == 200:
            return [ response.json()[&#39;id&#39;], createObject[ &#39;title&#39; ] ]
        else:
            raise Exception ( &#34;API Response ({}) was:\n\n{}&#34;.format( rc, response.content ) )

    def updatePage( self, newTitle, contentHtml, pageID, spaceKey, version=None, session=None ):
        &#34;&#34;&#34;helper function to update a pages content&#34;&#34;&#34;
        if version == None:
            version = self.getPageInfoByID( pageID )[ &#39;version&#39; ][ &#39;number&#39; ] + 1

        createObject = {
            &#34;id&#34;: pageID,
            &#34;type&#34;: &#34;page&#34;,
            &#34;title&#34;: newTitle,
            &#34;space&#34;: {
                &#34;key&#34;: spaceKey
            },
            &#34;body&#34;: {
                &#34;storage&#34;: {
                    &#34;value&#34;: contentHtml,
                    &#34;representation&#34;: &#34;storage&#34;
                }
            },
            &#34;version&#34;: {
                &#34;number&#34;: version
            }
        }

        createUrl = &#39;{url}rest/api/content/{pid}&#39;.format( url=self.app[ &#39;url&#39; ], pid=pageID )
        response  = self.sessionPutRequest( createUrl, createObject, session=session )
        rc = response.status_code

        if rc == 200:
            return response.json()[&#39;id&#39;]
        else:
            raise Exception ( &#34;API Response ({}) was:\n\n{}&#34;.format( rc, response.content ) )

    def getPageContent( self, pageID, session=None ):
        &#34;&#34;&#34;helper function to retrieve content of page by pageID&#34;&#34;&#34;
        apiUrl = &#39;{url}rest/api/content/{pid}?expand=body.storage&#39;.format( url=self.app[ &#39;url&#39; ], pid=pid )
        if session == None:
            session = self.toSession( curl = True )
        rspC = session.get( apiUrl )
        if rspC.status_code == 200:
            rsp = json.loads( rspC.text )
            return rsp[ &#39;body&#39; ][ &#39;storage&#39; ][ &#39;value&#39; ]
        else:
            return None


    def deletePage( self, pageID, session=None ):
        &#34;&#34;&#34;helper function to delete a given page&#34;&#34;&#34;
        if session == None:
            session = self.toSession( curl = True )
        rsp = session.delete( &#39;{url}rest/api/content/{id}&#39;.format( url=self.app[ &#39;url&#39; ], id=pageID ) )
        return rsp

    def getGroups( self ):
        &#34;&#34;&#34;Retrieve Confluence local groups&#34;&#34;&#34;
        cgroups = []
        session = self.toSession()
        stop = False
        i = 0
        while True:
            limit = 1000
            rspC = session.get(&#39;{url}rest/api/group?start={start}&amp;limit={limit}&#39;.format( url=self.app[ &#39;url&#39; ], limit=limit, start=( i * limit ) ) )
            if rspC.status_code == 200:
                rsp = json.loads( rspC.text )
                for g in rsp[&#39;results&#39;]:
                    cgroups.append( g[&#39;name&#39;] )
            else:
                stop = True

            if stop or len( rsp[&#39;results&#39;] ) == 0:
                break
            else:
                i += 1
        return cgroups

    def webSudo( self, adjustCookies = True ):
        &#34;&#34;&#34;run Confluence websudo&#34;&#34;&#34;
        authUrl    = &#39;{url}authenticate.action&#39;.format( url=self.app[ &#39;url&#39; ] )
        sysInfoUrl = &#39;{url}admin/viewgeneralconfig.action&#39;.format( url=self.app[ &#39;url&#39; ] )
        super( Confluence, self ).webSudo( authUrl, sysInfoUrl, adjustCookies )

    def getSpaceKeys( self, force = False, personalSpaces = False ):
        &#34;&#34;&#34;get all space keys of Confluence spaces through API&#34;&#34;&#34;
        # self.webSudo()
        session = self.toSession( curl=True )
        if force or self.spaceKeys == []:
            self.spaceKeys = []
            stop = False
            i = 0
            users = []
            while True:
                limit = 50
                start = i * limit
                apiUrl = &#39;{url}rest/api/space?start={start}&amp;limit={limit}&#39;.format( url=self.app[ &#39;url&#39; ], start=start, limit=limit )
                rspJ = session.get( apiUrl )
                if rspJ.status_code == 200:
                    rsp = json.loads( rspJ.text )
                    if rsp[ &#39;size&#39; ] &lt; limit:
                        stop = True
                    for k in rsp[ &#39;results&#39; ]:
                        if personalSpaces or k[ &#39;type&#39; ] not in [ &#39;personal&#39; ]:
                            self.spaceKeys.append( k[ &#39;key&#39; ] )
                else:
                    print(&#39;start: {s}, limit: {l}, rc: {r}&#39;.format( s=start, l=limit, r=str(rspJ.status_code) ) )
                    stop = True
                if stop or len( rsp[&#39;results&#39;] ) == 0:
                    break
                else:
                    i += 1
        return self.spaceKeys

    def getSpaceKeysGUI( self, force=False ):
        &#34;&#34;&#34;get all space keys of Confluence spaces through GUI&#34;&#34;&#34;
        if force or self.spaceKeys == []:
            self.spaceKeys = []
            self.get( self.app[ &#39;url&#39; ] + &#39;spacedirectory/view.action&#39; )
            while True:
                soup = self.toSoup()
                self.spaceKeys += [ item[ &#39;data-spacekey&#39; ] for item in soup.select( &#39;tbody tr&#39; ) ]
                try:
                    nextBtn = soup.select( &#39;.aui-nav-next a&#39; )[0]
                    check   = nextBtn[ &#39;href&#39; ]
                    self.browser.find_element( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, normalize-space(@class), &#34; &#34;), &#34; aui-nav-next &#34;)]//a&#39; ).click()
                    time.sleep( 5 )
                except:
                    break
        return self.spaceKeys

    def APIFileRequest( self, url, mime, filename, filecontent, transferCookies = False ):
        &#34;&#34;&#34;send a file through POST request into space&#34;&#34;&#34;
        session = self.toSession( curl=True )
        attachData = {
            &#34;bodyType&#34;: &#34;storage&#34;,
            &#34;supportedContainerTypes&#34;: [
                &#34;space&#34;,
                &#34;page&#34;
            ],
                &#34;supportedChildTypes&#34;: [
                &#34;attachment&#34;,
                &#34;comment&#34;
            ],
            &#34;supportedSpacePermissions&#34;: [],
            &#34;preventDuplicateTitle&#34;: False,
            &#34;indexing&#34;: {
                &#34;enabled&#34;: True
            },
            &#34;files&#34;: {
                &#39;file&#39;: ( filename, filecontent, mime )
            }
        }

        request = session.post( url, data = attachData, headers = { &#34;Content-Type&#34;: &#34;multipart/form-data&#34;, &#34;X-Atlassian-Token&#34;: &#34;no-check&#34; } )
        if transferCookies:
            # write Cookies from POST request to Selenium Browser
            new_cookies = session.cookies.get_dict()
            self.browser.get( request.url )
            for key, value in new_cookies.items():
                self.browser.add_cookie( { &#34;name&#34;: key, &#34;value&#34;: value } )
            self.get( request.url )
        return request

    def cleanupPermissions( self ):
        &#34;&#34;&#34;function to clean up permissions in spaces&#34;&#34;&#34;
        editPermissionUrl = self.app[ &#39;url&#39; ] + &#39;spaces/editspacepermissions.action?edit=Edit+Permissions&amp;key=&#39;
        userCheckApiUrl   = self.app[ &#39;url&#39; ] + &#39;rest/api/user?username=&#39;
        admingroupname    = os.getenv( &#39;CONFLUENCE_ADMIN_GROUP&#39;, &#39;confluence-administrators&#39; )
        self.getSpaceKeys()
        session = self.toSession()
        resp = session.get( userCheckApiUrl + self.app[ &#39;user&#39; ] )
        if resp.status_code == 403:
            self.login()
            self.webSudo()
            session = self.toSession()
        for space in self.spaceKeys:
            self.get( editPermissionUrl + space )
            rows         = self.browser.find_elements( By.XPATH, &#39;//*[@id=&#34;uPermissionsTable&#34;]//tr&#39;)[2:]
            removedUsers = []
            for row in rows:
                username   = row.find_element( By.XPATH,&#39;.//span&#39;).text[1:-1]
                userApiUrl = userCheckApiUrl + username
                resp       = session.get( userApiUrl )
                if resp.status_code == 200:
                    # User exists, all fine
                    pass
                elif resp.status_code == 404:
                    removedUsers += [ username ]
                    row.find_element( By.XPATH,&#39;.//td[1]//button&#39;).click()
                    # User does not exist, remove all permissions
                else:
                    raise APIError( resp.status_code, userApiUrl )
            time.sleep(4)
            self.browser.find_element( By.XPATH,&#39;//input[@name=&#34;save&#34; and @type=&#34;submit&#34;]&#39;).click()
            time.sleep(2)
            self.get( editPermissionUrl + space )
            rows = self.browser.find_elements( By.XPATH, &#39;//*[@id=&#34;uPermissionsTable&#34;]//tr&#39;)[2:]
            for row in rows:
                username   = row.find_element( By.XPATH,&#39;.//span&#39;).text[1:-1]
                if username in removedUsers:
                    row.find_element( By.XPATH,&#39;.//td[1]//button&#39;).click()
            self.browser.find_element( By.XPATH,&#39;//input[@name=&#34;save&#34; and @type=&#34;submit&#34;]&#39;).click()
            time.sleep(2)
            self.get( editPermissionUrl + space )
            rows = self.browser.find_elements( By.XPATH, &#39;//*[@id=&#34;uPermissionsTable&#34;]//tr&#39;)[2:]
            admins_added = False
            for row in rows:
                username   = row.find_element( By.XPATH,&#39;.//span&#39;).text[1:-1]
                if username in removedUsers:
                    if not admins_added:
                        groupaddfield = self.browser.find_element( By.ID,&#39;groups-to-add-autocomplete&#39;)
                        groupaddfield.send_keys( Keys.CONTROL, &#34;a&#34; )
                        groupaddfield.send_keys( admingroupname )
                        self.browser.find_element( By.XPATH, &#39;//*[@name=&#34;groupsToAddButton&#34; and @type=&#34;submit&#34;]&#39; ).click()
                        time.sleep(2)
                        self.browser.find_element( By.XPATH, &#39;//*[@id=&#34;gPermissionsTable&#34;]//*[contains(text(), &#34;&#39; + admingroupname + &#39;&#34;)]//button&#39; ).click()
                        admins_added = True
                        break
            if admins_added:
                rows = self.browser.find_elements( By.XPATH, &#39;//*[@id=&#34;uPermissionsTable&#34;]//tr&#39;)[2:]
                for row in rows:
                    username   = row.find_element( By.XPATH,&#39;.//span&#39;).text[1:-1]
                    if username in removedUsers:
                        row.find_element( By.XPATH,&#39;.//td[1]//button&#39;).click()
            self.browser.find_element( By.XPATH,&#39;//input[@name=&#34;save&#34; and @type=&#34;submit&#34;]&#39;).click()
            time.sleep(2)

    def getPermissionRepresentation( self, boolList, trueVal=&#39;X&#39;, falseVal=&#39;-&#39; ):
        &#34;&#34;&#34;generate a simple representation of a permission row for Confluence space&#34;&#34;&#34;
        rep = &#39;&#39;
        for x in boolList:
            if x:
                rep += trueVal
            else:
                rep += falseVal
        return rep

    def getBoolListFromRepresentation( self, representation, trueVal=&#39;X&#39;, falseVal=&#39;-&#39; ):
        &#34;&#34;&#34;revert representation of a permission row for Confluence space to boolean list&#34;&#34;&#34;
        boolList = []
        for c in representation:
            if c == trueVal:
                boolList.append( True )
            elif c == falseVal:
                boolList.append( False )
            else:
                raise Exception( &#39;Check your representation – trueVal (\&#39;{trueVal}\&#39;) and falseVal (\&#39;{falseVal}\&#39;) are not matched by \&#39;{val}\&#39;!&#39;.format( trueVal=trueVal, falseVal=falseVal, val=c ) )
        return boolList

    def getAllSpacePermissions( self, force=False, debug=True ):
        &#34;&#34;&#34;function to retrieve all space permissions in Confluence&#34;&#34;&#34;
        if force or self.permissions == {}:
            self.permissions = {}
            self.getSpaceKeys()
            for space in self.spaceKeys:
                self.permissions[ space ] = self.getSpacePermissions( space )
        return self.permissions

    def getSpacePermissions( self, spaceKey, force=False, debug=False ):
        &#34;&#34;&#34;function to retrieve space permissions for one Confluence space specified through Space Key&#34;&#34;&#34;
        if force or spaceKey not in self.permissions:
            permissionUrl = &#39;{url}spaces/spacepermissions.action?key={space}&#39;.format( url=self.app[ &#39;url&#39; ], space=spaceKey )
            if debug:
                print( spaceKey )
            self.get( permissionUrl )
            soup = self.toSoup()
            if self.permissionsNames == []:
                mainPerms = [ item.text for item in soup.select(&#39;table.permissions tr:first-of-type&#39;)[0].find_all(&#39;th&#39;)[1:] ]
                i = 0
                for item in soup.select(&#39;table.permissions tr:nth-of-type(2)&#39;)[0].find_all(&#39;th&#39;)[1:]:
                    try:
                        if &#39;permissions-group-start&#39; in item[ &#39;class&#39; ]:
                            i += 1
                    except:
                        pass
                    self.permissionsNames += [ mainPerms[ i ] + &#39; (&#39; + item.text + &#39;)&#39; ]
            tempPermissions = {}
            anonymous = soup.select(&#39;#aPermissionsTable tr:not(:first-of-type):not(:nth-of-type(2))&#39;)[0].select( &#39;td&#39; )
            tempPermissions[ &#39;ANONYMOUS&#39; ] = { &#39;anonymous&#39;: self.fetchPermissionsFromRow( anonymous[1:] ) }
            users     = soup.select(&#39;#uPermissionsTable tr:not(:first-of-type):not(:nth-of-type(2))&#39;)
            tempPermissions[ &#39;USERS&#39; ] = {}
            for row in users:
                tds = row.select( &#39;td&#39; )
                tempPermissions[ &#39;USERS&#39; ][ tds[0].select( &#39;span&#39; )[0].text.strip()[1:-1] ] = self.fetchPermissionsFromRow( tds[1:] )
            groups    = soup.select(&#39;#gPermissionsTable tr:not(:first-of-type):not(:nth-of-type(2))&#39;)
            tempPermissions[ &#39;GROUPS&#39; ] = {}
            for row in groups:
                tds = row.select( &#39;td&#39; )
                tempPermissions[ &#39;GROUPS&#39; ][ tds[0].text.strip() ] = self.fetchPermissionsFromRow( tds[1:] )
            return tempPermissions
        else:
            return self.permissions[ spaceKey ]

    def fetchPermissionsFromRow( self, row ):
        &#34;&#34;&#34;helper function to fetch permissions from one table row in permission view of Confluence space&#34;&#34;&#34;
        return [ item[ &#39;data-permission-set&#39; ].lower() != &#39;false&#39; for item in row ]

    def getGroupMembers( self, group ):
        &#34;&#34;&#34;Retrieve group member usernames from Confluence&#34;&#34;&#34;
        sessionC = self.toSession()
        stop = False
        i = 0
        users = []
        limit = 50
        firstRun = True
        while True:
            parameters = {
                &#39;start&#39;: ( i * limit ),
                &#39;limit&#39;: limit,
            }
            memberUrl = &#39;{url}rest/api/group/{group}/member?{params}&#39;.format( url=self.app[ &#39;url&#39; ], group=group, params=urllib.parse.urlencode( parameters ) )
            rspC = sessionC.get( memberUrl )

            if rspC.status_code == 200:
                rsp = json.loads( rspC.text )
                if firstRun and ( rsp[ &#39;size&#39; ] &lt; rsp[ &#39;limit&#39; ] or limit != rsp[ &#39;limit&#39; ] ):
                    limit = rsp[ &#39;size&#39; ]
                elif rsp[ &#39;size&#39; ] &lt; limit:
                    stop = True
                for u in rsp[&#39;results&#39;]:
                    users.append( u[ &#39;username&#39; ] )
            else:
                print(&#39;rc: &#39; + str(rspC.status_code))
                print(parameters)
                stop = True

            if stop or len( rsp[&#39;results&#39;] ) == 0:
                len( rsp[&#39;results&#39;] )
                break
            else:
                i += 1
            firstRun = False
        return users

    def getUserApiInfo( self, username, returnResponse=False, session=None ):
        &#34;&#34;&#34;Function to gather information about a user from API – if `returnResponse` is True, the whole request response is returned, otherwise only the decoded answer object&#34;&#34;&#34;
        apiUrl = &#39;{url}rest/mobile/latest/profile/{user}&#39;.format( url=self.app[&#39;url&#39;], user=urllib.parse.quote( username ) )
        return self.apiGetInfo( apiUrl, returnResponse, session )

    def recoverConfluencePermissions( self ):
        &#34;&#34;&#34;Function to recover confluence permissions if a system administrator has no space access. ENSURE YOUR SYSTEM LANGUAGE TO BE ENGLISH!&#34;&#34;&#34;
        permsurl = &#39;{url}/admin/permissions/viewdefaultspacepermissions.action&#39;.format( url=self.app[&#39;url&#39;] )
        self.browser.get( permsurl )
        xpath = &#39;//a[text()=&#34;Recover Permissions&#34;]&#39;
        xpathOk = &#39;//button[text()=&#34;OK&#34;]&#39;
        okJS = &#39;xPathRes = document.evaluate (\&#39;{xpath}\&#39;, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null); xPathRes.singleNodeValue.click();&#39;.format( xpath=xpathOk )
        listOfSpaces = []
        try:
            element = self.browser.find_element( By.XPATH, xpath )
            element.location_once_scrolled_into_view
        except:
            element = False
        while element:
            listOfSpaces += [ element.get_attribute( &#39;data-space-key&#39; ) ]
            element.click()
            WebDriverWait( self.browser, 10 ).until( EC.presence_of_element_located( ( By.XPATH, xpathOk ) ) )
            self.browser.execute_script( okJS )
            WebDriverWait( self.browser, 10 ).until_not( EC.presence_of_element_located( ( By.ID, &#39;recover-permissions-dialog&#39; ) ) )
            time.sleep( 0.5 )
            try:
                element = self.browser.find_element( By.XPATH, xpath )
                element.location_once_scrolled_into_view
            except:
                element = False
        return listOfSpaces

    def getAllSpacePermissionsAsRepresentation( self, force=False, debug=True, trueVal=&#39;X&#39;, falseVal=&#39;-&#39; ):
        &#34;&#34;&#34;
        Function to retrieve dictionary of permission representations.
        First level keys are space keys followed by second key as (like in getAllSpacePermissions) categories `GROUPS`, `USERS` and `ANONYMOUS`.
        The last key-level of the result dictionary is the granted object identifier (group name, user name or `anonymous`) followed by the representation.
        &#34;&#34;&#34;
        perms = self.getAllSpacePermissions( force, debug )
        vperms = {}
        for spacekey, permissions in perms.items():
            vperms[ spacekey ] = {}
            for category, specificperms in permissions.items():
                vperms[ spacekey ][ category ] = {}
                for key, permarray in specificperms.items():
                    vperms[ spacekey ][ category ][ key ] = self.getPermissionRepresentation( permarray, trueVal, falseVal )
        return vperms

    def addNewSpacePermissions( self, spaceKey, category, objectName, representation, isRepresentation=True, submitChanges=True ):
        &#34;&#34;&#34;Function to add new space permissions – if `isRepresentation` is `False`, a boolean list for permissions is expected.&#34;&#34;&#34;
        self.callPermissionChangePage( spaceKey )
        if category == &#39;GROUPS&#39;:
            gfield = self.browser.find_element_by_xpath( &#39;//input[@name=&#34;groupsToAdd&#34;]&#39; )
            gfield.send_keys( Keys.CONTROL, &#34;a&#34; )
            gfield.send_keys( objectName )
            time.sleep(1)
            self.browser.find_element( By.XPATH, &#39;//input[@name=&#34;groupsToAddButton&#34;]&#39; ).click()
        elif category == &#39;USERS&#39;:
            gfield = self.browser.find_element_by_xpath( &#39;//input[@name=&#34;usersToAdd&#34;]&#39; )
            gfield.send_keys( Keys.CONTROL, &#34;a&#34; )
            gfield.send_keys( objectName )
            time.sleep(1)
            self.browser.find_element( By.XPATH, &#39;//input[@name=&#34;usersToAddButton&#34;]&#39; ).click()
        elif category == &#39;ANONYMOUS&#39;:
            # ANONYMOUS has only one row which is always present
            pass
        else:
            raise Exception( &#39;{val} is an invalid category!&#39;.format( val=category ) )
        time.sleep(1)
        self.adjustSpacePermissions( spaceKey, category, objectName, representation, isRepresentation, submitChanges )

    def adjustSpacePermissions( self, spaceKey, category, objectName, representation, isRepresentation=True, submitChanges=True ):
        &#34;&#34;&#34;Function to change existing space permissions – if `isRepresentation` is `False`, a boolean list for permissions is expected.&#34;&#34;&#34;
        self.callPermissionChangePage( spaceKey )
        if isRepresentation:
            representation = self.getBoolListFromRepresentation( representation )
        try:
            permissionCheckboxes = self.selectObjectRowForSpacePermissionChange( category, objectName, spaceKey )
            if os.getenv( &#34;PRINT_DEBUG_INFO&#34;, &#34;False&#34; ).lower() in [ &#34;1&#34;, &#34;true&#34;, &#34;t&#34;, &#34;y&#34;, &#34;yes&#34; ]:
                rc  = len( representation )
                pcc = len( permissionCheckboxes )
                if rc != pcc:
                    print( &#39;Representation length ({rc}) and permission checkboxes lenght ({pcc}) do not match! Values are mapped as far as possible.&#39;.format( rc=rc, pcc=pcc ) )
                    print()
            for i, granted in enumerate( representation ):
                try:
                    element = permissionCheckboxes[ i ].find_element( By.XPATH, &#39;.//input[@type=&#34;checkbox&#34;]&#39; )
                    while element.is_selected() != granted:
                        element.click()
                except:
                    pass
            if submitChanges:
                self.submitSpacePermissionChange()
        except:
            if os.getenv( &#34;PRINT_DEBUG_INFO&#34;, &#34;False&#34; ).lower() in [ &#34;1&#34;, &#34;true&#34;, &#34;t&#34;, &#34;y&#34;, &#34;yes&#34; ]:
                print( &#39;Object {obj} in category {cat} could not be found for space with key {sk} ...&#39;.format( obj=objectName, cat=category, sk=spaceKey ) )

    def removeSpacePermissions( self, spaceKey, category, objectName, submitChanges=True ):
        &#34;&#34;&#34;Function to remove permissions from space&#34;&#34;&#34;
        self.callPermissionChangePage( spaceKey )
        try:
            permissionCheckboxes = self.selectObjectRowForSpacePermissionChange( category, objectName, spaceKey )
            for element in permissionCheckboxes:
                checkbox = element.find_element( By.XPATH, &#39;.//input[@type=&#34;checkbox&#34;]&#39; )
                while checkbox.is_selected():
                    checkbox.click()
            if submitChanges:
                self.submitSpacePermissionChange()
        except:
            if os.getenv( &#34;PRINT_DEBUG_INFO&#34;, &#34;False&#34; ).lower() in [ &#34;1&#34;, &#34;true&#34;, &#34;t&#34;, &#34;y&#34;, &#34;yes&#34; ]:
                print( &#39;Object {obj} in category {cat} could not be found for space with key {sk} ...&#39;.format( obj=objectName, cat=category, sk=spaceKey ) )

    def selectObjectRowForSpacePermissionChange( self, category, objectName, spaceKey ):
        &#34;&#34;&#34;Helper function to select the correct row for changing permissions&#34;&#34;&#34;
        xpathPermissionCell = &#39;.//*[contains(concat(&#34; &#34;, normalize-space(@class), &#34; &#34;), &#34; permissionCell &#34;)]&#39;
        if category == &#39;GROUPS&#39;:
            permissionRow = self.browser.find_element( By.XPATH, &#39;//td[@data-permission-group=\&#39;{obj}\&#39;][1]/parent::tr&#39;.format( obj=objectName ) )
        elif category == &#39;USERS&#39;:
            permissionRow = self.browser.find_element( By.XPATH, &#39;//td[@data-permission-user=\&#39;{obj}\&#39;][1]/parent::tr&#39;.format( obj=objectName ) )
        elif category == &#39;ANONYMOUS&#39;:
            permissionRow = self.browser.find_element( By.ID, &#39;aPermissionsTable&#39; )
            permissionRow = permissionRow.find_element( By.XPATH, &#39;{xpath}[1]/parent::tr&#39;.format( xpath=xpathPermissionCell) )
        else:
            raise Exception( &#39;{val} is an invalid category!&#39;.format( val=category ) )
        permissionCheckboxes = permissionRow.find_elements( By.XPATH, xpathPermissionCell )
        pcc = len( permissionCheckboxes )
        if pcc != 14:
            raise Exception( &#39;There are {c} permission checkboxes found for object {obj} in space permissions for space with key {sk}! (14 expected ...)&#39;.format( c=pcc, obj=objectName, sk=spaceKey ) )
        return permissionCheckboxes

    def callPermissionChangePage( self, spaceKey ):
        &#34;&#34;&#34;Helper function to call permission change page for a specified Confluence space&#34;&#34;&#34;
        url = &#39;{url}spaces/editspacepermissions.action?key={space}&#39;.format( url=self.app[&#39;url&#39;], space=spaceKey )
        if self.browser.current_url != url:
            self.webSudo()
            self.get( url )

    def submitSpacePermissionChange( self ):
        &#34;&#34;&#34;Submit the permission changes on space permission change page of confluence&#34;&#34;&#34;
        time.sleep(1)
        self.browser.find_element( By.XPATH, &#39;//input[@name=&#34;save&#34;]&#39; ).click()

    def setSpacePermissions( self, spaceKey, representationDictionary, forceRefresh=False ):
        &#34;&#34;&#34;Function meant to adjust space permissions to match a representation dictionary like returned by `getAllSpacePermissionsAsRepresentation`.&#34;&#34;&#34;
        currentPermissions = self.getSpacePermissions( spaceKey, forceRefresh )
        for category in representationDictionary:
            for objectName, newPermissions in representationDictionary[ category ].items():
                if objectName not in currentPermissions[ category ]:
                    self.addNewSpacePermissions( spaceKey, category, objectName, newPermissions, submitChanges=False )
                else:
                    self.adjustSpacePermissions( spaceKey, category, objectName, newPermissions, submitChanges=False )
        # removing permissions has to be the last step since it could be that space permissions then lock out the current user
        for category in representationDictionary:
            for objectName in currentPermissions[ category ]:
                if objectName not in representationDictionary[ category ]:
                    self.removeSpacePermissions( spaceKey, category, objectName, submitChanges=False )
        self.submitSpacePermissionChange()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Atlassian.Atlassian" href="#Atlassian.Atlassian">Atlassian</a></li>
<li>macwinnie_pyhelpers.Browser.Browser</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="Atlassian.Confluence.appInfo"><code class="name">var <span class="ident">appInfo</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Atlassian.Confluence.permissions"><code class="name">var <span class="ident">permissions</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Atlassian.Confluence.permissionsNames"><code class="name">var <span class="ident">permissionsNames</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Atlassian.Confluence.spaceKeys"><code class="name">var <span class="ident">spaceKeys</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Atlassian.Confluence.spaceNames"><code class="name">var <span class="ident">spaceNames</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Atlassian.Confluence.APIFileRequest"><code class="name flex">
<span>def <span class="ident">APIFileRequest</span></span>(<span>self, url, mime, filename, filecontent, transferCookies=False)</span>
</code></dt>
<dd>
<div class="desc"><p>send a file through POST request into space</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def APIFileRequest( self, url, mime, filename, filecontent, transferCookies = False ):
    &#34;&#34;&#34;send a file through POST request into space&#34;&#34;&#34;
    session = self.toSession( curl=True )
    attachData = {
        &#34;bodyType&#34;: &#34;storage&#34;,
        &#34;supportedContainerTypes&#34;: [
            &#34;space&#34;,
            &#34;page&#34;
        ],
            &#34;supportedChildTypes&#34;: [
            &#34;attachment&#34;,
            &#34;comment&#34;
        ],
        &#34;supportedSpacePermissions&#34;: [],
        &#34;preventDuplicateTitle&#34;: False,
        &#34;indexing&#34;: {
            &#34;enabled&#34;: True
        },
        &#34;files&#34;: {
            &#39;file&#39;: ( filename, filecontent, mime )
        }
    }

    request = session.post( url, data = attachData, headers = { &#34;Content-Type&#34;: &#34;multipart/form-data&#34;, &#34;X-Atlassian-Token&#34;: &#34;no-check&#34; } )
    if transferCookies:
        # write Cookies from POST request to Selenium Browser
        new_cookies = session.cookies.get_dict()
        self.browser.get( request.url )
        for key, value in new_cookies.items():
            self.browser.add_cookie( { &#34;name&#34;: key, &#34;value&#34;: value } )
        self.get( request.url )
    return request</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.addNewSpacePermissions"><code class="name flex">
<span>def <span class="ident">addNewSpacePermissions</span></span>(<span>self, spaceKey, category, objectName, representation, isRepresentation=True, submitChanges=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to add new space permissions – if <code>isRepresentation</code> is <code>False</code>, a boolean list for permissions is expected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addNewSpacePermissions( self, spaceKey, category, objectName, representation, isRepresentation=True, submitChanges=True ):
    &#34;&#34;&#34;Function to add new space permissions – if `isRepresentation` is `False`, a boolean list for permissions is expected.&#34;&#34;&#34;
    self.callPermissionChangePage( spaceKey )
    if category == &#39;GROUPS&#39;:
        gfield = self.browser.find_element_by_xpath( &#39;//input[@name=&#34;groupsToAdd&#34;]&#39; )
        gfield.send_keys( Keys.CONTROL, &#34;a&#34; )
        gfield.send_keys( objectName )
        time.sleep(1)
        self.browser.find_element( By.XPATH, &#39;//input[@name=&#34;groupsToAddButton&#34;]&#39; ).click()
    elif category == &#39;USERS&#39;:
        gfield = self.browser.find_element_by_xpath( &#39;//input[@name=&#34;usersToAdd&#34;]&#39; )
        gfield.send_keys( Keys.CONTROL, &#34;a&#34; )
        gfield.send_keys( objectName )
        time.sleep(1)
        self.browser.find_element( By.XPATH, &#39;//input[@name=&#34;usersToAddButton&#34;]&#39; ).click()
    elif category == &#39;ANONYMOUS&#39;:
        # ANONYMOUS has only one row which is always present
        pass
    else:
        raise Exception( &#39;{val} is an invalid category!&#39;.format( val=category ) )
    time.sleep(1)
    self.adjustSpacePermissions( spaceKey, category, objectName, representation, isRepresentation, submitChanges )</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.adjustSpacePermissions"><code class="name flex">
<span>def <span class="ident">adjustSpacePermissions</span></span>(<span>self, spaceKey, category, objectName, representation, isRepresentation=True, submitChanges=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to change existing space permissions – if <code>isRepresentation</code> is <code>False</code>, a boolean list for permissions is expected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjustSpacePermissions( self, spaceKey, category, objectName, representation, isRepresentation=True, submitChanges=True ):
    &#34;&#34;&#34;Function to change existing space permissions – if `isRepresentation` is `False`, a boolean list for permissions is expected.&#34;&#34;&#34;
    self.callPermissionChangePage( spaceKey )
    if isRepresentation:
        representation = self.getBoolListFromRepresentation( representation )
    try:
        permissionCheckboxes = self.selectObjectRowForSpacePermissionChange( category, objectName, spaceKey )
        if os.getenv( &#34;PRINT_DEBUG_INFO&#34;, &#34;False&#34; ).lower() in [ &#34;1&#34;, &#34;true&#34;, &#34;t&#34;, &#34;y&#34;, &#34;yes&#34; ]:
            rc  = len( representation )
            pcc = len( permissionCheckboxes )
            if rc != pcc:
                print( &#39;Representation length ({rc}) and permission checkboxes lenght ({pcc}) do not match! Values are mapped as far as possible.&#39;.format( rc=rc, pcc=pcc ) )
                print()
        for i, granted in enumerate( representation ):
            try:
                element = permissionCheckboxes[ i ].find_element( By.XPATH, &#39;.//input[@type=&#34;checkbox&#34;]&#39; )
                while element.is_selected() != granted:
                    element.click()
            except:
                pass
        if submitChanges:
            self.submitSpacePermissionChange()
    except:
        if os.getenv( &#34;PRINT_DEBUG_INFO&#34;, &#34;False&#34; ).lower() in [ &#34;1&#34;, &#34;true&#34;, &#34;t&#34;, &#34;y&#34;, &#34;yes&#34; ]:
            print( &#39;Object {obj} in category {cat} could not be found for space with key {sk} ...&#39;.format( obj=objectName, cat=category, sk=spaceKey ) )</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.callPermissionChangePage"><code class="name flex">
<span>def <span class="ident">callPermissionChangePage</span></span>(<span>self, spaceKey)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to call permission change page for a specified Confluence space</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def callPermissionChangePage( self, spaceKey ):
    &#34;&#34;&#34;Helper function to call permission change page for a specified Confluence space&#34;&#34;&#34;
    url = &#39;{url}spaces/editspacepermissions.action?key={space}&#39;.format( url=self.app[&#39;url&#39;], space=spaceKey )
    if self.browser.current_url != url:
        self.webSudo()
        self.get( url )</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.checkLogin"><code class="name flex">
<span>def <span class="ident">checkLogin</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if login is needed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkLogin( self ):
    &#34;&#34;&#34;Check if login is needed&#34;&#34;&#34;
    currentUrl = self.browser.current_url
    urlLen     = len( self.app[ &#39;url&#39; ] )
    if currentUrl[ 0:urlLen ] != self.app[ &#39;url&#39; ]:
        self.get( self.app[ &#39;url&#39; ], False )
    try:
        self.browser.find_element( By.ID, &#39;loginButton&#39; )
        return False
    except:
        return True</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.cleanupPermissions"><code class="name flex">
<span>def <span class="ident">cleanupPermissions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>function to clean up permissions in spaces</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanupPermissions( self ):
    &#34;&#34;&#34;function to clean up permissions in spaces&#34;&#34;&#34;
    editPermissionUrl = self.app[ &#39;url&#39; ] + &#39;spaces/editspacepermissions.action?edit=Edit+Permissions&amp;key=&#39;
    userCheckApiUrl   = self.app[ &#39;url&#39; ] + &#39;rest/api/user?username=&#39;
    admingroupname    = os.getenv( &#39;CONFLUENCE_ADMIN_GROUP&#39;, &#39;confluence-administrators&#39; )
    self.getSpaceKeys()
    session = self.toSession()
    resp = session.get( userCheckApiUrl + self.app[ &#39;user&#39; ] )
    if resp.status_code == 403:
        self.login()
        self.webSudo()
        session = self.toSession()
    for space in self.spaceKeys:
        self.get( editPermissionUrl + space )
        rows         = self.browser.find_elements( By.XPATH, &#39;//*[@id=&#34;uPermissionsTable&#34;]//tr&#39;)[2:]
        removedUsers = []
        for row in rows:
            username   = row.find_element( By.XPATH,&#39;.//span&#39;).text[1:-1]
            userApiUrl = userCheckApiUrl + username
            resp       = session.get( userApiUrl )
            if resp.status_code == 200:
                # User exists, all fine
                pass
            elif resp.status_code == 404:
                removedUsers += [ username ]
                row.find_element( By.XPATH,&#39;.//td[1]//button&#39;).click()
                # User does not exist, remove all permissions
            else:
                raise APIError( resp.status_code, userApiUrl )
        time.sleep(4)
        self.browser.find_element( By.XPATH,&#39;//input[@name=&#34;save&#34; and @type=&#34;submit&#34;]&#39;).click()
        time.sleep(2)
        self.get( editPermissionUrl + space )
        rows = self.browser.find_elements( By.XPATH, &#39;//*[@id=&#34;uPermissionsTable&#34;]//tr&#39;)[2:]
        for row in rows:
            username   = row.find_element( By.XPATH,&#39;.//span&#39;).text[1:-1]
            if username in removedUsers:
                row.find_element( By.XPATH,&#39;.//td[1]//button&#39;).click()
        self.browser.find_element( By.XPATH,&#39;//input[@name=&#34;save&#34; and @type=&#34;submit&#34;]&#39;).click()
        time.sleep(2)
        self.get( editPermissionUrl + space )
        rows = self.browser.find_elements( By.XPATH, &#39;//*[@id=&#34;uPermissionsTable&#34;]//tr&#39;)[2:]
        admins_added = False
        for row in rows:
            username   = row.find_element( By.XPATH,&#39;.//span&#39;).text[1:-1]
            if username in removedUsers:
                if not admins_added:
                    groupaddfield = self.browser.find_element( By.ID,&#39;groups-to-add-autocomplete&#39;)
                    groupaddfield.send_keys( Keys.CONTROL, &#34;a&#34; )
                    groupaddfield.send_keys( admingroupname )
                    self.browser.find_element( By.XPATH, &#39;//*[@name=&#34;groupsToAddButton&#34; and @type=&#34;submit&#34;]&#39; ).click()
                    time.sleep(2)
                    self.browser.find_element( By.XPATH, &#39;//*[@id=&#34;gPermissionsTable&#34;]//*[contains(text(), &#34;&#39; + admingroupname + &#39;&#34;)]//button&#39; ).click()
                    admins_added = True
                    break
        if admins_added:
            rows = self.browser.find_elements( By.XPATH, &#39;//*[@id=&#34;uPermissionsTable&#34;]//tr&#39;)[2:]
            for row in rows:
                username   = row.find_element( By.XPATH,&#39;.//span&#39;).text[1:-1]
                if username in removedUsers:
                    row.find_element( By.XPATH,&#39;.//td[1]//button&#39;).click()
        self.browser.find_element( By.XPATH,&#39;//input[@name=&#34;save&#34; and @type=&#34;submit&#34;]&#39;).click()
        time.sleep(2)</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.createPage"><code class="name flex">
<span>def <span class="ident">createPage</span></span>(<span>self, title, contentHtml, spaceKey, parent=None, session=None)</span>
</code></dt>
<dd>
<div class="desc"><p>helper function to create new pages within Confluence</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createPage( self, title, contentHtml, spaceKey, parent=None, session=None ):
    &#34;&#34;&#34;helper function to create new pages within Confluence&#34;&#34;&#34;
    if parent == None:
        parent = getSpaceHomepageID( spaceKey )

    createUrl    = &#39;{url}rest/api/content&#39;.format( url=self.app[ &#39;url&#39; ] )
    createObject = {
        &#34;type&#34;: &#34;page&#34;,
        &#34;title&#34;: title,
        &#34;space&#34;: {
            &#34;key&#34;: spaceKey
        },
        &#34;body&#34;: {
            &#34;storage&#34;: {
                &#34;value&#34;: contentHtml,
                &#34;representation&#34;: &#34;storage&#34;
            }
        },
        &#34;ancestors&#34;: [{
            &#34;id&#34;: parent
        }]
    }

    response = self.sessionPostRequest( createUrl, createObject, session )
    rc = response.status_code

    i = 1
    title = createObject[ &#39;title&#39; ]

    while rc != 200 and &#39;already exists&#39; in response.json()[&#39;message&#39;].lower():
        print( &#39;    &#39; + response.json()[&#39;message&#39;] )
        createObject[ &#39;title&#39; ] = &#39;{} ({})&#39;.format( title, i )
        response = self.sessionPostRequest( createUrl, createObject, session )
        rc = response.status_code
        i += 1

    if rc == 200:
        return [ response.json()[&#39;id&#39;], createObject[ &#39;title&#39; ] ]
    else:
        raise Exception ( &#34;API Response ({}) was:\n\n{}&#34;.format( rc, response.content ) )</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.deletePage"><code class="name flex">
<span>def <span class="ident">deletePage</span></span>(<span>self, pageID, session=None)</span>
</code></dt>
<dd>
<div class="desc"><p>helper function to delete a given page</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deletePage( self, pageID, session=None ):
    &#34;&#34;&#34;helper function to delete a given page&#34;&#34;&#34;
    if session == None:
        session = self.toSession( curl = True )
    rsp = session.delete( &#39;{url}rest/api/content/{id}&#39;.format( url=self.app[ &#39;url&#39; ], id=pageID ) )
    return rsp</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.fetchPermissionsFromRow"><code class="name flex">
<span>def <span class="ident">fetchPermissionsFromRow</span></span>(<span>self, row)</span>
</code></dt>
<dd>
<div class="desc"><p>helper function to fetch permissions from one table row in permission view of Confluence space</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetchPermissionsFromRow( self, row ):
    &#34;&#34;&#34;helper function to fetch permissions from one table row in permission view of Confluence space&#34;&#34;&#34;
    return [ item[ &#39;data-permission-set&#39; ].lower() != &#39;false&#39; for item in row ]</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.getAllSpacePermissions"><code class="name flex">
<span>def <span class="ident">getAllSpacePermissions</span></span>(<span>self, force=False, debug=True)</span>
</code></dt>
<dd>
<div class="desc"><p>function to retrieve all space permissions in Confluence</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAllSpacePermissions( self, force=False, debug=True ):
    &#34;&#34;&#34;function to retrieve all space permissions in Confluence&#34;&#34;&#34;
    if force or self.permissions == {}:
        self.permissions = {}
        self.getSpaceKeys()
        for space in self.spaceKeys:
            self.permissions[ space ] = self.getSpacePermissions( space )
    return self.permissions</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.getAllSpacePermissionsAsRepresentation"><code class="name flex">
<span>def <span class="ident">getAllSpacePermissionsAsRepresentation</span></span>(<span>self, force=False, debug=True, trueVal='X', falseVal='-')</span>
</code></dt>
<dd>
<div class="desc"><p>Function to retrieve dictionary of permission representations.
First level keys are space keys followed by second key as (like in getAllSpacePermissions) categories <code>GROUPS</code>, <code>USERS</code> and <code>ANONYMOUS</code>.
The last key-level of the result dictionary is the granted object identifier (group name, user name or <code>anonymous</code>) followed by the representation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAllSpacePermissionsAsRepresentation( self, force=False, debug=True, trueVal=&#39;X&#39;, falseVal=&#39;-&#39; ):
    &#34;&#34;&#34;
    Function to retrieve dictionary of permission representations.
    First level keys are space keys followed by second key as (like in getAllSpacePermissions) categories `GROUPS`, `USERS` and `ANONYMOUS`.
    The last key-level of the result dictionary is the granted object identifier (group name, user name or `anonymous`) followed by the representation.
    &#34;&#34;&#34;
    perms = self.getAllSpacePermissions( force, debug )
    vperms = {}
    for spacekey, permissions in perms.items():
        vperms[ spacekey ] = {}
        for category, specificperms in permissions.items():
            vperms[ spacekey ][ category ] = {}
            for key, permarray in specificperms.items():
                vperms[ spacekey ][ category ][ key ] = self.getPermissionRepresentation( permarray, trueVal, falseVal )
    return vperms</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.getBoolListFromRepresentation"><code class="name flex">
<span>def <span class="ident">getBoolListFromRepresentation</span></span>(<span>self, representation, trueVal='X', falseVal='-')</span>
</code></dt>
<dd>
<div class="desc"><p>revert representation of a permission row for Confluence space to boolean list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getBoolListFromRepresentation( self, representation, trueVal=&#39;X&#39;, falseVal=&#39;-&#39; ):
    &#34;&#34;&#34;revert representation of a permission row for Confluence space to boolean list&#34;&#34;&#34;
    boolList = []
    for c in representation:
        if c == trueVal:
            boolList.append( True )
        elif c == falseVal:
            boolList.append( False )
        else:
            raise Exception( &#39;Check your representation – trueVal (\&#39;{trueVal}\&#39;) and falseVal (\&#39;{falseVal}\&#39;) are not matched by \&#39;{val}\&#39;!&#39;.format( trueVal=trueVal, falseVal=falseVal, val=c ) )
    return boolList</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.getGroupMembers"><code class="name flex">
<span>def <span class="ident">getGroupMembers</span></span>(<span>self, group)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve group member usernames from Confluence</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getGroupMembers( self, group ):
    &#34;&#34;&#34;Retrieve group member usernames from Confluence&#34;&#34;&#34;
    sessionC = self.toSession()
    stop = False
    i = 0
    users = []
    limit = 50
    firstRun = True
    while True:
        parameters = {
            &#39;start&#39;: ( i * limit ),
            &#39;limit&#39;: limit,
        }
        memberUrl = &#39;{url}rest/api/group/{group}/member?{params}&#39;.format( url=self.app[ &#39;url&#39; ], group=group, params=urllib.parse.urlencode( parameters ) )
        rspC = sessionC.get( memberUrl )

        if rspC.status_code == 200:
            rsp = json.loads( rspC.text )
            if firstRun and ( rsp[ &#39;size&#39; ] &lt; rsp[ &#39;limit&#39; ] or limit != rsp[ &#39;limit&#39; ] ):
                limit = rsp[ &#39;size&#39; ]
            elif rsp[ &#39;size&#39; ] &lt; limit:
                stop = True
            for u in rsp[&#39;results&#39;]:
                users.append( u[ &#39;username&#39; ] )
        else:
            print(&#39;rc: &#39; + str(rspC.status_code))
            print(parameters)
            stop = True

        if stop or len( rsp[&#39;results&#39;] ) == 0:
            len( rsp[&#39;results&#39;] )
            break
        else:
            i += 1
        firstRun = False
    return users</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.getGroups"><code class="name flex">
<span>def <span class="ident">getGroups</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve Confluence local groups</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getGroups( self ):
    &#34;&#34;&#34;Retrieve Confluence local groups&#34;&#34;&#34;
    cgroups = []
    session = self.toSession()
    stop = False
    i = 0
    while True:
        limit = 1000
        rspC = session.get(&#39;{url}rest/api/group?start={start}&amp;limit={limit}&#39;.format( url=self.app[ &#39;url&#39; ], limit=limit, start=( i * limit ) ) )
        if rspC.status_code == 200:
            rsp = json.loads( rspC.text )
            for g in rsp[&#39;results&#39;]:
                cgroups.append( g[&#39;name&#39;] )
        else:
            stop = True

        if stop or len( rsp[&#39;results&#39;] ) == 0:
            break
        else:
            i += 1
    return cgroups</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.getPageContent"><code class="name flex">
<span>def <span class="ident">getPageContent</span></span>(<span>self, pageID, session=None)</span>
</code></dt>
<dd>
<div class="desc"><p>helper function to retrieve content of page by pageID</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPageContent( self, pageID, session=None ):
    &#34;&#34;&#34;helper function to retrieve content of page by pageID&#34;&#34;&#34;
    apiUrl = &#39;{url}rest/api/content/{pid}?expand=body.storage&#39;.format( url=self.app[ &#39;url&#39; ], pid=pid )
    if session == None:
        session = self.toSession( curl = True )
    rspC = session.get( apiUrl )
    if rspC.status_code == 200:
        rsp = json.loads( rspC.text )
        return rsp[ &#39;body&#39; ][ &#39;storage&#39; ][ &#39;value&#39; ]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.getPageInfo"><code class="name flex">
<span>def <span class="ident">getPageInfo</span></span>(<span>self, spaceKey, title, session=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to get page information by Confluence space key and page title</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPageInfo( self, spaceKey, title, session=None ):
    &#34;&#34;&#34;Function to get page information by Confluence space key and page title&#34;&#34;&#34;
    self.setSessionBaseHeaders( api=True )
    parameters = {
        &#39;spaceKey&#39;: spaceKey,
        &#39;title&#39;:    title,
        &#39;expand&#39;:   &#39;version,space&#39;,
    }
    apiUrl  = &#39;{url}rest/api/content?{params}&#39;.format( url=self.app[ &#39;url&#39; ], params=urllib.parse.urlencode( parameters ) )
    results = self.apiGetInfo( apiUrl, session=session )
    if results[ &#39;size&#39; ] &gt; 1:
        raise Exception( &#39;More than one page found – cannot proceed properly ...&#39; )
    return results[ &#39;results&#39; ][ 0 ]</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.getPageInfoByID"><code class="name flex">
<span>def <span class="ident">getPageInfoByID</span></span>(<span>self, pageID, session=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to get page information by page ID</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPageInfoByID( self, pageID, session=None ):
    &#34;&#34;&#34;Function to get page information by page ID&#34;&#34;&#34;
    self.setSessionBaseHeaders( api=True )
    parameters = {
        &#39;expand&#39;:   &#39;version,space&#39;,
    }
    apiUrl = &#39;{url}rest/api/content/{id}?{params}&#39;.format( url=self.app[ &#39;url&#39; ], id=pageID, params=urllib.parse.urlencode( parameters ) )
    result = self.apiGetInfo( apiUrl, session=session )
    return result</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.getPermissionRepresentation"><code class="name flex">
<span>def <span class="ident">getPermissionRepresentation</span></span>(<span>self, boolList, trueVal='X', falseVal='-')</span>
</code></dt>
<dd>
<div class="desc"><p>generate a simple representation of a permission row for Confluence space</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPermissionRepresentation( self, boolList, trueVal=&#39;X&#39;, falseVal=&#39;-&#39; ):
    &#34;&#34;&#34;generate a simple representation of a permission row for Confluence space&#34;&#34;&#34;
    rep = &#39;&#39;
    for x in boolList:
        if x:
            rep += trueVal
        else:
            rep += falseVal
    return rep</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.getSpaceHomepageID"><code class="name flex">
<span>def <span class="ident">getSpaceHomepageID</span></span>(<span>self, spaceKey, session=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to get page ID of homepage of Space</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSpaceHomepageID( self, spaceKey, session=None ):
    &#34;&#34;&#34;Helper function to get page ID of homepage of Space&#34;&#34;&#34;
    self.setSessionBaseHeaders( api=True )
    parameters = {
        &#39;expand&#39;:   &#39;homepage&#39;,
        &#39;spaceKey&#39;: spaceKey,
    }
    apiUrl = &#39;{url}rest/api/space?{params}&#39;.format( url=self.app[ &#39;url&#39; ], id=pageID, params=urllib.parse.urlencode( parameters ) )
    result = self.apiGetInfo( apiUrl, session=session )
    if result != None:
        return result[ &#39;results&#39; ][ 0 ][ &#39;homepage&#39; ][ &#39;id&#39; ]</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.getSpaceKeyFromName"><code class="name flex">
<span>def <span class="ident">getSpaceKeyFromName</span></span>(<span>self, spaceName, force=False, session=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to retrieve space key by space name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSpaceKeyFromName( self, spaceName, force=False, session=None ):
    &#34;&#34;&#34;Helper function to retrieve space key by space name&#34;&#34;&#34;
    if len( self.spaceNames ) == 0 or force == True:
        sks = self.getSpaceKeys()
        for sk in sks:
            self.spaceNames[ self.getSpaceName( sk ) ] = sk
    if spaceName in self.spaceNames:
        return self.spaceNames[ spaceName ]</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.getSpaceKeys"><code class="name flex">
<span>def <span class="ident">getSpaceKeys</span></span>(<span>self, force=False, personalSpaces=False)</span>
</code></dt>
<dd>
<div class="desc"><p>get all space keys of Confluence spaces through API</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSpaceKeys( self, force = False, personalSpaces = False ):
    &#34;&#34;&#34;get all space keys of Confluence spaces through API&#34;&#34;&#34;
    # self.webSudo()
    session = self.toSession( curl=True )
    if force or self.spaceKeys == []:
        self.spaceKeys = []
        stop = False
        i = 0
        users = []
        while True:
            limit = 50
            start = i * limit
            apiUrl = &#39;{url}rest/api/space?start={start}&amp;limit={limit}&#39;.format( url=self.app[ &#39;url&#39; ], start=start, limit=limit )
            rspJ = session.get( apiUrl )
            if rspJ.status_code == 200:
                rsp = json.loads( rspJ.text )
                if rsp[ &#39;size&#39; ] &lt; limit:
                    stop = True
                for k in rsp[ &#39;results&#39; ]:
                    if personalSpaces or k[ &#39;type&#39; ] not in [ &#39;personal&#39; ]:
                        self.spaceKeys.append( k[ &#39;key&#39; ] )
            else:
                print(&#39;start: {s}, limit: {l}, rc: {r}&#39;.format( s=start, l=limit, r=str(rspJ.status_code) ) )
                stop = True
            if stop or len( rsp[&#39;results&#39;] ) == 0:
                break
            else:
                i += 1
    return self.spaceKeys</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.getSpaceKeysGUI"><code class="name flex">
<span>def <span class="ident">getSpaceKeysGUI</span></span>(<span>self, force=False)</span>
</code></dt>
<dd>
<div class="desc"><p>get all space keys of Confluence spaces through GUI</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSpaceKeysGUI( self, force=False ):
    &#34;&#34;&#34;get all space keys of Confluence spaces through GUI&#34;&#34;&#34;
    if force or self.spaceKeys == []:
        self.spaceKeys = []
        self.get( self.app[ &#39;url&#39; ] + &#39;spacedirectory/view.action&#39; )
        while True:
            soup = self.toSoup()
            self.spaceKeys += [ item[ &#39;data-spacekey&#39; ] for item in soup.select( &#39;tbody tr&#39; ) ]
            try:
                nextBtn = soup.select( &#39;.aui-nav-next a&#39; )[0]
                check   = nextBtn[ &#39;href&#39; ]
                self.browser.find_element( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, normalize-space(@class), &#34; &#34;), &#34; aui-nav-next &#34;)]//a&#39; ).click()
                time.sleep( 5 )
            except:
                break
    return self.spaceKeys</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.getSpaceName"><code class="name flex">
<span>def <span class="ident">getSpaceName</span></span>(<span>self, spaceKey, session=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to retrieve the space name of a Confluence Space</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSpaceName( self, spaceKey, session=None ):
    &#34;&#34;&#34;Helper function to retrieve the space name of a Confluence Space&#34;&#34;&#34;
    self.setSessionBaseHeaders( api=True )
    apiUrl = &#39;{url}rest/api/space/{spaceKey}&#39;.format( url=self.app[ &#39;url&#39; ], spaceKey=spaceKey )
    result = self.apiGetInfo( apiUrl, session=session )
    if result != None:
        return result[ &#39;name&#39; ]</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.getSpacePermissions"><code class="name flex">
<span>def <span class="ident">getSpacePermissions</span></span>(<span>self, spaceKey, force=False, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>function to retrieve space permissions for one Confluence space specified through Space Key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSpacePermissions( self, spaceKey, force=False, debug=False ):
    &#34;&#34;&#34;function to retrieve space permissions for one Confluence space specified through Space Key&#34;&#34;&#34;
    if force or spaceKey not in self.permissions:
        permissionUrl = &#39;{url}spaces/spacepermissions.action?key={space}&#39;.format( url=self.app[ &#39;url&#39; ], space=spaceKey )
        if debug:
            print( spaceKey )
        self.get( permissionUrl )
        soup = self.toSoup()
        if self.permissionsNames == []:
            mainPerms = [ item.text for item in soup.select(&#39;table.permissions tr:first-of-type&#39;)[0].find_all(&#39;th&#39;)[1:] ]
            i = 0
            for item in soup.select(&#39;table.permissions tr:nth-of-type(2)&#39;)[0].find_all(&#39;th&#39;)[1:]:
                try:
                    if &#39;permissions-group-start&#39; in item[ &#39;class&#39; ]:
                        i += 1
                except:
                    pass
                self.permissionsNames += [ mainPerms[ i ] + &#39; (&#39; + item.text + &#39;)&#39; ]
        tempPermissions = {}
        anonymous = soup.select(&#39;#aPermissionsTable tr:not(:first-of-type):not(:nth-of-type(2))&#39;)[0].select( &#39;td&#39; )
        tempPermissions[ &#39;ANONYMOUS&#39; ] = { &#39;anonymous&#39;: self.fetchPermissionsFromRow( anonymous[1:] ) }
        users     = soup.select(&#39;#uPermissionsTable tr:not(:first-of-type):not(:nth-of-type(2))&#39;)
        tempPermissions[ &#39;USERS&#39; ] = {}
        for row in users:
            tds = row.select( &#39;td&#39; )
            tempPermissions[ &#39;USERS&#39; ][ tds[0].select( &#39;span&#39; )[0].text.strip()[1:-1] ] = self.fetchPermissionsFromRow( tds[1:] )
        groups    = soup.select(&#39;#gPermissionsTable tr:not(:first-of-type):not(:nth-of-type(2))&#39;)
        tempPermissions[ &#39;GROUPS&#39; ] = {}
        for row in groups:
            tds = row.select( &#39;td&#39; )
            tempPermissions[ &#39;GROUPS&#39; ][ tds[0].text.strip() ] = self.fetchPermissionsFromRow( tds[1:] )
        return tempPermissions
    else:
        return self.permissions[ spaceKey ]</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.getUserApiInfo"><code class="name flex">
<span>def <span class="ident">getUserApiInfo</span></span>(<span>self, username, returnResponse=False, session=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to gather information about a user from API – if <code>returnResponse</code> is True, the whole request response is returned, otherwise only the decoded answer object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getUserApiInfo( self, username, returnResponse=False, session=None ):
    &#34;&#34;&#34;Function to gather information about a user from API – if `returnResponse` is True, the whole request response is returned, otherwise only the decoded answer object&#34;&#34;&#34;
    apiUrl = &#39;{url}rest/mobile/latest/profile/{user}&#39;.format( url=self.app[&#39;url&#39;], user=urllib.parse.quote( username ) )
    return self.apiGetInfo( apiUrl, returnResponse, session )</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.login"><code class="name flex">
<span>def <span class="ident">login</span></span>(<span>self, skipSSO=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Run Confluence login</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def login( self, skipSSO=True ):
    &#34;&#34;&#34;Run Confluence login&#34;&#34;&#34;
    loginUrl = self.app[ &#39;url&#39; ] + &#34;dologin.action&#34;
    if skipSSO:
        loginUrl += &#39;?nosso&#39;
    self.loadCookies( url=loginUrl )
    self.setSessionBaseHeaders()
    userObject = { &#34;os_username&#34;: self.app[ &#39;user&#39; ], &#34;os_password&#34;: self.app[ &#39;passwd&#39; ], &#34;os_cookie&#34;: &#34;true&#34;, &#34;login&#34;: &#34;Log in&#34;, &#34;os_destination&#34;: &#34;&#34;, }
    if os.getenv( &#34;PRINT_DEBUG_INFO&#34;, &#34;False&#34; ).lower() in [ &#34;1&#34;, &#34;true&#34;, &#34;t&#34;, &#34;y&#34;, &#34;yes&#34; ]:
        print( &#39;User is being logged in with those credentials:&#39; )
        print( userObject )
        print()
    self.sessionPostRequest( loginUrl, userObject, True, urlOverride=True )
    self.get( self.app[ &#39;url&#39; ] , False )</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.recoverConfluencePermissions"><code class="name flex">
<span>def <span class="ident">recoverConfluencePermissions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to recover confluence permissions if a system administrator has no space access. ENSURE YOUR SYSTEM LANGUAGE TO BE ENGLISH!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recoverConfluencePermissions( self ):
    &#34;&#34;&#34;Function to recover confluence permissions if a system administrator has no space access. ENSURE YOUR SYSTEM LANGUAGE TO BE ENGLISH!&#34;&#34;&#34;
    permsurl = &#39;{url}/admin/permissions/viewdefaultspacepermissions.action&#39;.format( url=self.app[&#39;url&#39;] )
    self.browser.get( permsurl )
    xpath = &#39;//a[text()=&#34;Recover Permissions&#34;]&#39;
    xpathOk = &#39;//button[text()=&#34;OK&#34;]&#39;
    okJS = &#39;xPathRes = document.evaluate (\&#39;{xpath}\&#39;, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null); xPathRes.singleNodeValue.click();&#39;.format( xpath=xpathOk )
    listOfSpaces = []
    try:
        element = self.browser.find_element( By.XPATH, xpath )
        element.location_once_scrolled_into_view
    except:
        element = False
    while element:
        listOfSpaces += [ element.get_attribute( &#39;data-space-key&#39; ) ]
        element.click()
        WebDriverWait( self.browser, 10 ).until( EC.presence_of_element_located( ( By.XPATH, xpathOk ) ) )
        self.browser.execute_script( okJS )
        WebDriverWait( self.browser, 10 ).until_not( EC.presence_of_element_located( ( By.ID, &#39;recover-permissions-dialog&#39; ) ) )
        time.sleep( 0.5 )
        try:
            element = self.browser.find_element( By.XPATH, xpath )
            element.location_once_scrolled_into_view
        except:
            element = False
    return listOfSpaces</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.removeSpacePermissions"><code class="name flex">
<span>def <span class="ident">removeSpacePermissions</span></span>(<span>self, spaceKey, category, objectName, submitChanges=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to remove permissions from space</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeSpacePermissions( self, spaceKey, category, objectName, submitChanges=True ):
    &#34;&#34;&#34;Function to remove permissions from space&#34;&#34;&#34;
    self.callPermissionChangePage( spaceKey )
    try:
        permissionCheckboxes = self.selectObjectRowForSpacePermissionChange( category, objectName, spaceKey )
        for element in permissionCheckboxes:
            checkbox = element.find_element( By.XPATH, &#39;.//input[@type=&#34;checkbox&#34;]&#39; )
            while checkbox.is_selected():
                checkbox.click()
        if submitChanges:
            self.submitSpacePermissionChange()
    except:
        if os.getenv( &#34;PRINT_DEBUG_INFO&#34;, &#34;False&#34; ).lower() in [ &#34;1&#34;, &#34;true&#34;, &#34;t&#34;, &#34;y&#34;, &#34;yes&#34; ]:
            print( &#39;Object {obj} in category {cat} could not be found for space with key {sk} ...&#39;.format( obj=objectName, cat=category, sk=spaceKey ) )</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.selectObjectRowForSpacePermissionChange"><code class="name flex">
<span>def <span class="ident">selectObjectRowForSpacePermissionChange</span></span>(<span>self, category, objectName, spaceKey)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to select the correct row for changing permissions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectObjectRowForSpacePermissionChange( self, category, objectName, spaceKey ):
    &#34;&#34;&#34;Helper function to select the correct row for changing permissions&#34;&#34;&#34;
    xpathPermissionCell = &#39;.//*[contains(concat(&#34; &#34;, normalize-space(@class), &#34; &#34;), &#34; permissionCell &#34;)]&#39;
    if category == &#39;GROUPS&#39;:
        permissionRow = self.browser.find_element( By.XPATH, &#39;//td[@data-permission-group=\&#39;{obj}\&#39;][1]/parent::tr&#39;.format( obj=objectName ) )
    elif category == &#39;USERS&#39;:
        permissionRow = self.browser.find_element( By.XPATH, &#39;//td[@data-permission-user=\&#39;{obj}\&#39;][1]/parent::tr&#39;.format( obj=objectName ) )
    elif category == &#39;ANONYMOUS&#39;:
        permissionRow = self.browser.find_element( By.ID, &#39;aPermissionsTable&#39; )
        permissionRow = permissionRow.find_element( By.XPATH, &#39;{xpath}[1]/parent::tr&#39;.format( xpath=xpathPermissionCell) )
    else:
        raise Exception( &#39;{val} is an invalid category!&#39;.format( val=category ) )
    permissionCheckboxes = permissionRow.find_elements( By.XPATH, xpathPermissionCell )
    pcc = len( permissionCheckboxes )
    if pcc != 14:
        raise Exception( &#39;There are {c} permission checkboxes found for object {obj} in space permissions for space with key {sk}! (14 expected ...)&#39;.format( c=pcc, obj=objectName, sk=spaceKey ) )
    return permissionCheckboxes</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.setSessionBaseHeaders"><code class="name flex">
<span>def <span class="ident">setSessionBaseHeaders</span></span>(<span>self, api=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Api requests need special headers in Confluence &hellip; sometimes &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setSessionBaseHeaders( self, api=False ):
    &#34;&#34;&#34;Api requests need special headers in Confluence ... sometimes ...&#34;&#34;&#34;
    if not api:
        self.sessionBaseHeaders = None
    else:
        self.sessionBaseHeaders = {
            &#34;Content-Type&#34;:      &#34;application/json&#34;,
            &#34;X-Atlassian-Token&#34;: &#34;no-check&#34;
        }</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.setSpacePermissions"><code class="name flex">
<span>def <span class="ident">setSpacePermissions</span></span>(<span>self, spaceKey, representationDictionary, forceRefresh=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Function meant to adjust space permissions to match a representation dictionary like returned by <code>getAllSpacePermissionsAsRepresentation</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setSpacePermissions( self, spaceKey, representationDictionary, forceRefresh=False ):
    &#34;&#34;&#34;Function meant to adjust space permissions to match a representation dictionary like returned by `getAllSpacePermissionsAsRepresentation`.&#34;&#34;&#34;
    currentPermissions = self.getSpacePermissions( spaceKey, forceRefresh )
    for category in representationDictionary:
        for objectName, newPermissions in representationDictionary[ category ].items():
            if objectName not in currentPermissions[ category ]:
                self.addNewSpacePermissions( spaceKey, category, objectName, newPermissions, submitChanges=False )
            else:
                self.adjustSpacePermissions( spaceKey, category, objectName, newPermissions, submitChanges=False )
    # removing permissions has to be the last step since it could be that space permissions then lock out the current user
    for category in representationDictionary:
        for objectName in currentPermissions[ category ]:
            if objectName not in representationDictionary[ category ]:
                self.removeSpacePermissions( spaceKey, category, objectName, submitChanges=False )
    self.submitSpacePermissionChange()</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.submitSpacePermissionChange"><code class="name flex">
<span>def <span class="ident">submitSpacePermissionChange</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Submit the permission changes on space permission change page of confluence</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def submitSpacePermissionChange( self ):
    &#34;&#34;&#34;Submit the permission changes on space permission change page of confluence&#34;&#34;&#34;
    time.sleep(1)
    self.browser.find_element( By.XPATH, &#39;//input[@name=&#34;save&#34;]&#39; ).click()</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.updatePage"><code class="name flex">
<span>def <span class="ident">updatePage</span></span>(<span>self, newTitle, contentHtml, pageID, spaceKey, version=None, session=None)</span>
</code></dt>
<dd>
<div class="desc"><p>helper function to update a pages content</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updatePage( self, newTitle, contentHtml, pageID, spaceKey, version=None, session=None ):
    &#34;&#34;&#34;helper function to update a pages content&#34;&#34;&#34;
    if version == None:
        version = self.getPageInfoByID( pageID )[ &#39;version&#39; ][ &#39;number&#39; ] + 1

    createObject = {
        &#34;id&#34;: pageID,
        &#34;type&#34;: &#34;page&#34;,
        &#34;title&#34;: newTitle,
        &#34;space&#34;: {
            &#34;key&#34;: spaceKey
        },
        &#34;body&#34;: {
            &#34;storage&#34;: {
                &#34;value&#34;: contentHtml,
                &#34;representation&#34;: &#34;storage&#34;
            }
        },
        &#34;version&#34;: {
            &#34;number&#34;: version
        }
    }

    createUrl = &#39;{url}rest/api/content/{pid}&#39;.format( url=self.app[ &#39;url&#39; ], pid=pageID )
    response  = self.sessionPutRequest( createUrl, createObject, session=session )
    rc = response.status_code

    if rc == 200:
        return response.json()[&#39;id&#39;]
    else:
        raise Exception ( &#34;API Response ({}) was:\n\n{}&#34;.format( rc, response.content ) )</code></pre>
</details>
</dd>
<dt id="Atlassian.Confluence.webSudo"><code class="name flex">
<span>def <span class="ident">webSudo</span></span>(<span>self, adjustCookies=True)</span>
</code></dt>
<dd>
<div class="desc"><p>run Confluence websudo</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def webSudo( self, adjustCookies = True ):
    &#34;&#34;&#34;run Confluence websudo&#34;&#34;&#34;
    authUrl    = &#39;{url}authenticate.action&#39;.format( url=self.app[ &#39;url&#39; ] )
    sysInfoUrl = &#39;{url}admin/viewgeneralconfig.action&#39;.format( url=self.app[ &#39;url&#39; ] )
    super( Confluence, self ).webSudo( authUrl, sysInfoUrl, adjustCookies )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Atlassian.Atlassian" href="#Atlassian.Atlassian">Atlassian</a></b></code>:
<ul class="hlist">
<li><code><a title="Atlassian.Atlassian.getToken" href="#Atlassian.Atlassian.getToken">getToken</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="Atlassian.Jira"><code class="flex name class">
<span>class <span class="ident">Jira</span></span>
</code></dt>
<dd>
<div class="desc"><p>Jira Browser – recommended to use administrative user; otherwise most functions won't work properly</p>
<p>function to initiate the systems as needed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Jira ( Atlassian ):
    &#34;&#34;&#34;Jira Browser – recommended to use administrative user; otherwise most functions won&#39;t work properly&#34;&#34;&#34;

    appInfo = {
        &#34;url&#34;:    {
            &#34;env&#34;:         &#34;JIRA_URL&#34;,
            &#34;url&#34;:         True,
            &#34;description&#34;: &#34;Enter Jira URL&#34;,
        },
        &#34;user&#34;:   {
            &#34;env&#34;:         &#34;JIRA_USER&#34;,
            &#34;description&#34;: &#34;Enter Jira username&#34;,
        },
        &#34;passwd&#34;: {
            &#34;password&#34;:    True,
            &#34;env&#34;:         &#34;JIRA_PASS&#34;,
            &#34;description&#34;: &#34;Enter Jira password&#34;,
        },
    }

    projectKeys  = []
    permissions  = {}
    projectLeads = {}

    def __init__( self ):
        super( Jira, self ).__init__()

    def setSessionBaseHeaders( self, api=False ):
        &#34;&#34;&#34;Api requests need special headers in Jira ... sometimes ...&#34;&#34;&#34;
        if not api:
            self.sessionBaseHeaders = None
        else:
            self.sessionBaseHeaders = {
                &#34;Content-Type&#34;:      &#34;application/json&#34;,
                &#34;X-Atlassian-Token&#34;: &#34;no-check&#34;
            }

    def login( self, skipSSO=True ):
        &#34;&#34;&#34;Run Jira login&#34;&#34;&#34;
        loginUrl = self.app[ &#39;url&#39; ] + &#34;login.jsp&#34;
        if skipSSO:
            loginUrl += &#39;?nosso&#39;
        self.loadCookies( url=loginUrl )
        self.setSessionBaseHeaders()
        userObject = { &#34;os_username&#34;: self.app[ &#39;user&#39; ], &#34;os_password&#34;: self.app[ &#39;passwd&#39; ], }
        if os.getenv( &#34;PRINT_DEBUG_INFO&#34;, &#34;False&#34; ).lower() in [ &#34;1&#34;, &#34;true&#34;, &#34;t&#34;, &#34;y&#34;, &#34;yes&#34; ]:
            print( &#39;User is being logged in with those credentials:&#39; )
            print( userObject )
            print()
        self.sessionPostRequest( loginUrl, userObject, True, urlOverride=True )
        self.get( self.app[ &#39;url&#39; ] , False )

    def checkLogin( self ):
        &#34;&#34;&#34;Check if login is needed&#34;&#34;&#34;
        currentUrl = self.browser.current_url
        urlLen     = len( self.app[ &#39;url&#39; ] )
        if currentUrl[ 0:urlLen ] != self.app[ &#39;url&#39; ]:
            self.get( self.app[ &#39;url&#39; ], False )
        try:
            self.browser.find_element( By.ID, &#39;login&#39; )
            return False
        except:
            return True

    def webSudo( self, adjustCookies = True ):
        &#34;&#34;&#34;Run the Jira WebSudo&#34;&#34;&#34;
        authUrl    = &#39;{url}secure/admin/WebSudoAuthenticate!default.jspa&#39;.format( url=self.app[ &#39;url&#39; ] )
        sysInfoUrl = &#39;{url}secure/admin/ViewApplicationProperties.jspa&#39;.format( url=self.app[ &#39;url&#39; ] )
        super( Jira, self ).webSudo( authUrl, sysInfoUrl, adjustCookies )

    def getProjectKeys( self ):
        &#34;&#34;&#34;Get a list of Project Keys of those Jira projects visible to logged in user&#34;&#34;&#34;
        self.webSudo()
        self.get( self.app[ &#39;url&#39; ] + &#39;secure/project/BrowseProjects.jspa&#39; )
        while True:
            soup = self.toSoup()
            self.projectKeys += [ item.text for item in soup.select( &#39;tbody tr .cell-type-key&#39; ) ]
            try:
                nextBtn = soup.select( &#39;.aui-nav-next a&#39; )[0]
                check   = nextBtn[ &#39;data-page&#39; ]
                self.browser.find_element( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, normalize-space(@class), &#34; &#34;), &#34; aui-nav-next &#34;)]//a&#39; ).click()
                time.sleep(5)
            except:
                break
        return self.projectKeys

    def getUserGroups( self, username, session=None ):
        &#34;&#34;&#34;Function to gather groups of user&#34;&#34;&#34;
        apiUrl = &#39;{url}rest/api/2/user?username={user}&amp;expand=groups&#39;.format( url=self.app[&#39;url&#39;], user=urllib.parse.quote( username ) )
        groups = self.apiGetInfo( apiUrl, session=session )
        return [ g[&#39;name&#39;] for g in groups[&#39;groups&#39;][&#39;items&#39;] ]

    def getUserApiInfo( self, username, returnResponse=False, session=None ):
        &#34;&#34;&#34;Function to gather information about a user from API – if `returnResponse` is True, the whole request response is returned, otherwise only the decoded answer object&#34;&#34;&#34;
        apiUrl = &#39;{url}rest/api/2/user?username={user}&#39;.format( url=self.app[&#39;url&#39;], user=urllib.parse.quote( username ) )
        return self.apiGetInfo( apiUrl, returnResponse, session )

    def getGroupApiInfo( self, groupname, returnResponse=False, session=None ):
        &#34;&#34;&#34;Function to gather information about a group from API – if `returnResponse` is True, the whole request response is returned, otherwise only the decoded answer object&#34;&#34;&#34;
        apiUrl = &#39;{url}rest/api/2/group?groupname={group}&#39;.format( url=self.app[&#39;url&#39;], group=urllib.parse.quote( groupname ) )
        return self.apiGetInfo( apiUrl, returnResponse, session )

    def gatherProjectPermissions( self, projectKey, session=None ):
        &#34;&#34;&#34;Function to gather permissions for a specific Jira project&#34;&#34;&#34;
        rolesDropdownXpath = &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; iLKsB &#34;)]&#39;
        projectPermissions = None
        self.get( &#39;{url}plugins/servlet/project-config/{pjkey}/roles&#39;.format( url=self.app[&#39;url&#39;], pjkey=projectKey ) )
        skip = True
        try:
            WebDriverWait( self.browser, 10 ).until( EC.presence_of_element_located( ( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; EKGYc &#34;)]&#39; ) ) )
            skip = False
        except:
            print( &#39;{p} skipped&#39;.format( p = projectKey ) )
        if not skip:
            projectPermissions = {}
            continueLookup = True
            # retrieve possible roles
            roleBtn = WebDriverWait( self.browser, 10 ).until(EC.element_to_be_clickable((By.XPATH, &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; css-18u3ks8 &#34;)]&#39;)))
            roleBtn.click()
            # wait until dropdown is visible
            WebDriverWait( self.browser, 10 ).until(EC.presence_of_element_located((By.XPATH, rolesDropdownXpath)))
            # kteeYD (selected, single one), goEvqh (selected, multiple ones), eJTYOK (not selected)
            roleElements = self.browser.find_elements( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; eJTYOk &#34;) or contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; goEvqh &#34;) or contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; kteeYD &#34;)]&#39; )
            for rl in roleElements:
                role = re.match( r&#39;^(.+?)(\s\([0-9]+\))?$&#39; ,rl.text ).group( 1 )
                projectPermissions[ role ] = {&#39;USERS&#39;:[], &#39;GROUPS&#39;:[]}
            try:
                roleBtn.click()
                WebDriverWait( self.browser, 10 ).until_not(EC.presence_of_element_located((By.XPATH, rolesDropdownXpath)))
            except:
                actions = ActionChains( self.browser )
                actions.send_keys( Keys.ESCAPE )
                actions.perform()
                WebDriverWait( self.browser, 10 ).until_not(EC.presence_of_element_located((By.XPATH, rolesDropdownXpath)))
            while continueLookup:
                # find all username and groupname fields on page
                nameFields = self.browser.find_elements( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; EKGYc &#34;)]&#39; )
                # fetch users for roles
                for x in nameFields:
                    n = x.text
                    trigger = x.find_element( By.XPATH, &#39;./parent::*/parent::*/parent::*/parent::*//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; css-8xpfx5 &#34;)]&#39; )
                    resp = self.getUserApiInfo( n, True, session )
                    index = None
                    if ( resp.status_code == 200 ):
                        index = &#39;USERS&#39;
                    else:
                        resp = self.getGroupApiInfo( n, True, session )
                        if ( resp.status_code == 200 ):
                            index = &#39;GROUPS&#39;
                    if index != None:
                        try:
                            trigger.click()
                            WebDriverWait( self.browser, 10 ).until(EC.presence_of_element_located((By.XPATH, rolesDropdownXpath)))
                            clicked = True
                        except:
                            actions = ActionChains( self.browser )
                            actions.send_keys( Keys.ESCAPE )
                            actions.perform()
                            try:
                                WebDriverWait( self.browser, 10 ).until(EC.presence_of_element_located((By.XPATH, rolesDropdownXpath)))
                            except Exception as e:
                                self.browser.get_screenshot_as_file(&#39;./data/debug/error_{index}_open_{date}.png&#39;.format( date = datetime.now().strftime(&#34;%Y%m%d_%H%M%S&#34;), index=index ))
                                raise e
                        roleElements = self.browser.find_elements( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; kteeYD &#34;) or contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; goEvqh &#34;)]&#39; )
                        for rl in roleElements:
                            projectPermissions[ rl.text ][ index ].append( n )
                        try:
                            trigger.click()
                            WebDriverWait( self.browser, 10 ).until_not(EC.presence_of_element_located((By.XPATH, rolesDropdownXpath)))
                            clicked = True
                        except:
                            actions = ActionChains( self.browser )
                            actions.send_keys( Keys.ESCAPE )
                            actions.perform()
                            try:
                                WebDriverWait( self.browser, 10 ).until_not(EC.presence_of_element_located((By.XPATH, rolesDropdownXpath)))
                            except Exception as e:
                                self.browser.get_screenshot_as_file(&#39;./data/debug/error_{index}_close_{date}.png&#39;.format( date = datetime.now().strftime(&#34;%Y%m%d_%H%M%S&#34;), index=index ))
                                raise e
                try:
                    self.browser.find_element( By.XPATH, &#39;//*[@aria-label=&#34;Next&#34; and not(@disabled)]&#39; ).click()
                except:
                    continueLookup = False
        return projectPermissions

    def getGroups( self ):
        &#34;&#34;&#34;get list of groupnames existing in Jira&#34;&#34;&#34;
        session = self.toSession()
        rspJ = session.get( &#39;{url}rest/api/2/groups/picker?maxResults={limit}&#39;.format( url=self.app[ &#39;url&#39; ], limit=5000 ) )
        jgroups = []
        if rspJ.status_code == 200:
            rsp = json.loads( rspJ.text )
            for g in rsp[&#39;groups&#39;]:
                jgroups.append( g[ &#39;name&#39; ] )
        return jgroups

    def removeUserFromGroup( self, group, user, session=None ):
        &#34;&#34;&#34;Remove user from group&#34;&#34;&#34;
        if session == None:
            session = self.toSession( curl = True )
        requestData = {
            &#39;groupname&#39;: group,
            &#39;username&#39;:  user
        }
        rsp = session.delete( &#39;{url}rest/api/2/group/user?{params}&#39;.format( url=self.app[ &#39;url&#39; ], params=urllib.parse.urlencode( requestData ) ) )
        return rsp

    def addUserToGroup( self, group, user, session=None ):
        &#34;&#34;&#34;Add user to group&#34;&#34;&#34;
        if session == None:
            session = self.toSession( curl = True )
        rsp = session.post( &#39;{url}rest/api/2/group/user?groupname={group}&#39;.format(url=self.app[&#39;url&#39;], group=group), data = json.dumps({&#39;name&#39;:user}), headers={&#39;content-type&#39;:&#39;application/json&#39;} )
        return rsp

    def getGroupMembers( self, group, activeFilter=&#39;true&#39; ):
        &#34;&#34;&#34;get group members from GUI&#34;&#34;&#34;
        self.webSudo()
        self.setSessionBaseHeaders()
        self.sessionPostRequest( &#39;{url}secure/admin/user/UserBrowser.jspa&#39;.format( url=self.app[&#39;url&#39;] ), { &#39;userSearchFilter&#39;: &#39;&#39;, &#39;group&#39;: group, &#39;applicationFilter&#39;: &#39;&#39;, &#39;activeFilter&#39;: activeFilter, &#39;max&#39;: 1000000 } , True )
        should = WebDriverWait( self.browser, 10 ).until( EC.presence_of_element_located( ( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; results-count &#34;)]//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; results-count-total &#34;)]&#39; ) ) ).text
        gms    = self.browser.find_elements( By.XPATH, &#39;//*[@data-cell-type=&#34;username&#34;]/ancestor::tr[position() = 1]&#39; )
        if len(gms) != int(should):
            raise Exception(&#39;Count-Missmatch with group members of &#34;{g}&#34;: {f} found, but {s} should have!&#39;.format(g=group, f=len(gms), s=should))
        users = []
        for i in gms:
            users.append( i.get_attribute( &#34;data-user&#34; ) )
        return users

    def getGroupMembersAPI( self, group ):
        &#34;&#34;&#34;get group members from API – sometimes a little bit buggy ...&#34;&#34;&#34;
        sessionJ = self.toSession()
        stop = False
        i = 0
        users = []
        while True:
            limit = 50
            parameters = {
                &#39;groupname&#39;: group,
                &#39;startAt&#39;: ( i * limit ),
                &#39;maxResults&#39;: limit,
                &#39;includeInactiveUsers&#39;: &#39;false&#39;,
            }
            memberUrl = &#39;{url}rest/api/2/group/member?{params}&#39;.format( url=self.app[ &#39;url&#39; ], params=urllib.parse.urlencode( parameters ) )
            rspJ = sessionJ.get( memberUrl )

            if rspJ.status_code == 200:
                rsp = json.loads( rspJ.text )
                if rsp[ &#39;isLast&#39; ] == True:
                    stop = True
                for u in rsp[&#39;values&#39;]:
                    users.append( u[ &#39;name&#39; ] )
            else:
                print(&#39;rc: &#39; + str(rspJ.status_code))
                print(parameters)
                stop = True

            if stop or len( rsp[&#39;values&#39;] ) == 0:
                len( rsp[&#39;values&#39;] )
                break
            else:
                i += 1
        return users

    def getActiveProjectLead( self, projectKey, session=None ):
        &#34;&#34;&#34;Function to retrieve project lead of Jira project, if the user is still active&#34;&#34;&#34;
        if session == None:
            session = self.toSession()
        self.browser.get( &#39;{url}plugins/servlet/project-config/{pjkey}/roles&#39;.format( url=self.app[&#39;url&#39;], pjkey=projectKey ) )
        plo = WebDriverWait( self.browser, 10 ).until( EC.presence_of_element_located( ( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; jKQrhX &#34;)]//a&#39; ) ) )
        parsedProfile = urlparse( plo.get_attribute(&#39;href&#39;) )
        ploUser = parse_qs(parsedProfile.query)[&#39;name&#39;][0]
        resp = session.get( &#39;{url}rest/api/2/user?username={user}&#39;.format( url=self.app[&#39;url&#39;], user=urllib.parse.quote( ploUser ) ) )
        try:
            userJson = json.loads( resp.text )
            active = userJson[&#39;active&#39;]
        except:
            active = False
        if ( resp.status_code == 200 and active):
            return ploUser
        else:
            return None

    def getProjectLeads( self ):
        &#34;&#34;&#34;Function to retrieve active project leads for all Jira projects&#34;&#34;&#34;
        if len( self.projectKeys ) == 0:
            self.getProjectKeys()
        if len( self.projectLeads ) == 0:
            session = self.toSession()
            for pk in self.projectKeys:
                self.projectLeads[ projectKey ] = self.getActiveProjectLead( pk, session )
        return self.projectLeads

    def gatherAllProjectPermissions( self, deletePermissionHelperFile=True ):
        &#34;&#34;&#34;Function to retrieve project permissions for all projects&#34;&#34;&#34;
        if len( self.projectKeys ) == 0:
            self.getProjectKeys()
        if len( self.permissions ) == 0:
            permissionHelperFile = &#39;./data/projectPermissionsHelper.json&#39;
            session = self.toSession()
            if not os.path.exists( os.path.dirname( permissionHelperFile ) ):
                os.makedirs( os.path.dirname( permissionHelperFile ), exist_ok=True)
            if not os.path.exists( permissionHelperFile ):
                with open( permissionHelperFile, &#39;w+&#39;):
                    pass
            with open( permissionHelperFile ) as json_file:
                self.permissions = json.load( json_file )
            for pk in self.projectKeys:
                if pk not in self.permissions:
                    print( pk )
                    self.permissions[ pk ] = self.gatherProjectPermissions( pk, session )
                with open( permissionHelperFile, &#39;w&#39; ) as json_file:
                        json.dump( self.permissions, json_file )
            print()
            if deletePermissionHelperFile:
                os.remove( permissionHelperFile )
        return self.permissions

    def createGroup( self, groupName ):
        &#34;&#34;&#34;Create a local user group&#34;&#34;&#34;
        groupUrl = self.app[ &#39;url&#39; ] + &#39;/secure/admin/user/GroupBrowser.jspa&#39;
        self.get( groupUrl )
        field = self.browser.find_element( By.XPATH, &#39;//input[@name=&#34;addName&#34;]&#39; )
        field.send_keys( Keys.CONTROL, &#34;a&#34; )
        field.send_keys( groupName )
        field.send_keys( Keys.ENTER )
        session = self.toSession()
        groupCreated = False
        while not groupCreated:
            time.sleep(1)
            rsp = session.get( &#39;{url}rest/api/latest/group?groupname={group}&#39;.format( url=self.app[ &#39;url&#39; ], group=urllib.parse.quote( groupName ) ) )
            groupCreated = ( rsp.status_code == 200 )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="Atlassian.Atlassian" href="#Atlassian.Atlassian">Atlassian</a></li>
<li>macwinnie_pyhelpers.Browser.Browser</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="Atlassian.Jira.appInfo"><code class="name">var <span class="ident">appInfo</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Atlassian.Jira.permissions"><code class="name">var <span class="ident">permissions</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Atlassian.Jira.projectKeys"><code class="name">var <span class="ident">projectKeys</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Atlassian.Jira.projectLeads"><code class="name">var <span class="ident">projectLeads</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Atlassian.Jira.addUserToGroup"><code class="name flex">
<span>def <span class="ident">addUserToGroup</span></span>(<span>self, group, user, session=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add user to group</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addUserToGroup( self, group, user, session=None ):
    &#34;&#34;&#34;Add user to group&#34;&#34;&#34;
    if session == None:
        session = self.toSession( curl = True )
    rsp = session.post( &#39;{url}rest/api/2/group/user?groupname={group}&#39;.format(url=self.app[&#39;url&#39;], group=group), data = json.dumps({&#39;name&#39;:user}), headers={&#39;content-type&#39;:&#39;application/json&#39;} )
    return rsp</code></pre>
</details>
</dd>
<dt id="Atlassian.Jira.checkLogin"><code class="name flex">
<span>def <span class="ident">checkLogin</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if login is needed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def checkLogin( self ):
    &#34;&#34;&#34;Check if login is needed&#34;&#34;&#34;
    currentUrl = self.browser.current_url
    urlLen     = len( self.app[ &#39;url&#39; ] )
    if currentUrl[ 0:urlLen ] != self.app[ &#39;url&#39; ]:
        self.get( self.app[ &#39;url&#39; ], False )
    try:
        self.browser.find_element( By.ID, &#39;login&#39; )
        return False
    except:
        return True</code></pre>
</details>
</dd>
<dt id="Atlassian.Jira.createGroup"><code class="name flex">
<span>def <span class="ident">createGroup</span></span>(<span>self, groupName)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a local user group</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createGroup( self, groupName ):
    &#34;&#34;&#34;Create a local user group&#34;&#34;&#34;
    groupUrl = self.app[ &#39;url&#39; ] + &#39;/secure/admin/user/GroupBrowser.jspa&#39;
    self.get( groupUrl )
    field = self.browser.find_element( By.XPATH, &#39;//input[@name=&#34;addName&#34;]&#39; )
    field.send_keys( Keys.CONTROL, &#34;a&#34; )
    field.send_keys( groupName )
    field.send_keys( Keys.ENTER )
    session = self.toSession()
    groupCreated = False
    while not groupCreated:
        time.sleep(1)
        rsp = session.get( &#39;{url}rest/api/latest/group?groupname={group}&#39;.format( url=self.app[ &#39;url&#39; ], group=urllib.parse.quote( groupName ) ) )
        groupCreated = ( rsp.status_code == 200 )</code></pre>
</details>
</dd>
<dt id="Atlassian.Jira.gatherAllProjectPermissions"><code class="name flex">
<span>def <span class="ident">gatherAllProjectPermissions</span></span>(<span>self, deletePermissionHelperFile=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to retrieve project permissions for all projects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gatherAllProjectPermissions( self, deletePermissionHelperFile=True ):
    &#34;&#34;&#34;Function to retrieve project permissions for all projects&#34;&#34;&#34;
    if len( self.projectKeys ) == 0:
        self.getProjectKeys()
    if len( self.permissions ) == 0:
        permissionHelperFile = &#39;./data/projectPermissionsHelper.json&#39;
        session = self.toSession()
        if not os.path.exists( os.path.dirname( permissionHelperFile ) ):
            os.makedirs( os.path.dirname( permissionHelperFile ), exist_ok=True)
        if not os.path.exists( permissionHelperFile ):
            with open( permissionHelperFile, &#39;w+&#39;):
                pass
        with open( permissionHelperFile ) as json_file:
            self.permissions = json.load( json_file )
        for pk in self.projectKeys:
            if pk not in self.permissions:
                print( pk )
                self.permissions[ pk ] = self.gatherProjectPermissions( pk, session )
            with open( permissionHelperFile, &#39;w&#39; ) as json_file:
                    json.dump( self.permissions, json_file )
        print()
        if deletePermissionHelperFile:
            os.remove( permissionHelperFile )
    return self.permissions</code></pre>
</details>
</dd>
<dt id="Atlassian.Jira.gatherProjectPermissions"><code class="name flex">
<span>def <span class="ident">gatherProjectPermissions</span></span>(<span>self, projectKey, session=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to gather permissions for a specific Jira project</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gatherProjectPermissions( self, projectKey, session=None ):
    &#34;&#34;&#34;Function to gather permissions for a specific Jira project&#34;&#34;&#34;
    rolesDropdownXpath = &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; iLKsB &#34;)]&#39;
    projectPermissions = None
    self.get( &#39;{url}plugins/servlet/project-config/{pjkey}/roles&#39;.format( url=self.app[&#39;url&#39;], pjkey=projectKey ) )
    skip = True
    try:
        WebDriverWait( self.browser, 10 ).until( EC.presence_of_element_located( ( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; EKGYc &#34;)]&#39; ) ) )
        skip = False
    except:
        print( &#39;{p} skipped&#39;.format( p = projectKey ) )
    if not skip:
        projectPermissions = {}
        continueLookup = True
        # retrieve possible roles
        roleBtn = WebDriverWait( self.browser, 10 ).until(EC.element_to_be_clickable((By.XPATH, &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; css-18u3ks8 &#34;)]&#39;)))
        roleBtn.click()
        # wait until dropdown is visible
        WebDriverWait( self.browser, 10 ).until(EC.presence_of_element_located((By.XPATH, rolesDropdownXpath)))
        # kteeYD (selected, single one), goEvqh (selected, multiple ones), eJTYOK (not selected)
        roleElements = self.browser.find_elements( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; eJTYOk &#34;) or contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; goEvqh &#34;) or contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; kteeYD &#34;)]&#39; )
        for rl in roleElements:
            role = re.match( r&#39;^(.+?)(\s\([0-9]+\))?$&#39; ,rl.text ).group( 1 )
            projectPermissions[ role ] = {&#39;USERS&#39;:[], &#39;GROUPS&#39;:[]}
        try:
            roleBtn.click()
            WebDriverWait( self.browser, 10 ).until_not(EC.presence_of_element_located((By.XPATH, rolesDropdownXpath)))
        except:
            actions = ActionChains( self.browser )
            actions.send_keys( Keys.ESCAPE )
            actions.perform()
            WebDriverWait( self.browser, 10 ).until_not(EC.presence_of_element_located((By.XPATH, rolesDropdownXpath)))
        while continueLookup:
            # find all username and groupname fields on page
            nameFields = self.browser.find_elements( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; EKGYc &#34;)]&#39; )
            # fetch users for roles
            for x in nameFields:
                n = x.text
                trigger = x.find_element( By.XPATH, &#39;./parent::*/parent::*/parent::*/parent::*//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; css-8xpfx5 &#34;)]&#39; )
                resp = self.getUserApiInfo( n, True, session )
                index = None
                if ( resp.status_code == 200 ):
                    index = &#39;USERS&#39;
                else:
                    resp = self.getGroupApiInfo( n, True, session )
                    if ( resp.status_code == 200 ):
                        index = &#39;GROUPS&#39;
                if index != None:
                    try:
                        trigger.click()
                        WebDriverWait( self.browser, 10 ).until(EC.presence_of_element_located((By.XPATH, rolesDropdownXpath)))
                        clicked = True
                    except:
                        actions = ActionChains( self.browser )
                        actions.send_keys( Keys.ESCAPE )
                        actions.perform()
                        try:
                            WebDriverWait( self.browser, 10 ).until(EC.presence_of_element_located((By.XPATH, rolesDropdownXpath)))
                        except Exception as e:
                            self.browser.get_screenshot_as_file(&#39;./data/debug/error_{index}_open_{date}.png&#39;.format( date = datetime.now().strftime(&#34;%Y%m%d_%H%M%S&#34;), index=index ))
                            raise e
                    roleElements = self.browser.find_elements( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; kteeYD &#34;) or contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; goEvqh &#34;)]&#39; )
                    for rl in roleElements:
                        projectPermissions[ rl.text ][ index ].append( n )
                    try:
                        trigger.click()
                        WebDriverWait( self.browser, 10 ).until_not(EC.presence_of_element_located((By.XPATH, rolesDropdownXpath)))
                        clicked = True
                    except:
                        actions = ActionChains( self.browser )
                        actions.send_keys( Keys.ESCAPE )
                        actions.perform()
                        try:
                            WebDriverWait( self.browser, 10 ).until_not(EC.presence_of_element_located((By.XPATH, rolesDropdownXpath)))
                        except Exception as e:
                            self.browser.get_screenshot_as_file(&#39;./data/debug/error_{index}_close_{date}.png&#39;.format( date = datetime.now().strftime(&#34;%Y%m%d_%H%M%S&#34;), index=index ))
                            raise e
            try:
                self.browser.find_element( By.XPATH, &#39;//*[@aria-label=&#34;Next&#34; and not(@disabled)]&#39; ).click()
            except:
                continueLookup = False
    return projectPermissions</code></pre>
</details>
</dd>
<dt id="Atlassian.Jira.getActiveProjectLead"><code class="name flex">
<span>def <span class="ident">getActiveProjectLead</span></span>(<span>self, projectKey, session=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to retrieve project lead of Jira project, if the user is still active</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getActiveProjectLead( self, projectKey, session=None ):
    &#34;&#34;&#34;Function to retrieve project lead of Jira project, if the user is still active&#34;&#34;&#34;
    if session == None:
        session = self.toSession()
    self.browser.get( &#39;{url}plugins/servlet/project-config/{pjkey}/roles&#39;.format( url=self.app[&#39;url&#39;], pjkey=projectKey ) )
    plo = WebDriverWait( self.browser, 10 ).until( EC.presence_of_element_located( ( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; jKQrhX &#34;)]//a&#39; ) ) )
    parsedProfile = urlparse( plo.get_attribute(&#39;href&#39;) )
    ploUser = parse_qs(parsedProfile.query)[&#39;name&#39;][0]
    resp = session.get( &#39;{url}rest/api/2/user?username={user}&#39;.format( url=self.app[&#39;url&#39;], user=urllib.parse.quote( ploUser ) ) )
    try:
        userJson = json.loads( resp.text )
        active = userJson[&#39;active&#39;]
    except:
        active = False
    if ( resp.status_code == 200 and active):
        return ploUser
    else:
        return None</code></pre>
</details>
</dd>
<dt id="Atlassian.Jira.getGroupApiInfo"><code class="name flex">
<span>def <span class="ident">getGroupApiInfo</span></span>(<span>self, groupname, returnResponse=False, session=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to gather information about a group from API – if <code>returnResponse</code> is True, the whole request response is returned, otherwise only the decoded answer object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getGroupApiInfo( self, groupname, returnResponse=False, session=None ):
    &#34;&#34;&#34;Function to gather information about a group from API – if `returnResponse` is True, the whole request response is returned, otherwise only the decoded answer object&#34;&#34;&#34;
    apiUrl = &#39;{url}rest/api/2/group?groupname={group}&#39;.format( url=self.app[&#39;url&#39;], group=urllib.parse.quote( groupname ) )
    return self.apiGetInfo( apiUrl, returnResponse, session )</code></pre>
</details>
</dd>
<dt id="Atlassian.Jira.getGroupMembers"><code class="name flex">
<span>def <span class="ident">getGroupMembers</span></span>(<span>self, group, activeFilter='true')</span>
</code></dt>
<dd>
<div class="desc"><p>get group members from GUI</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getGroupMembers( self, group, activeFilter=&#39;true&#39; ):
    &#34;&#34;&#34;get group members from GUI&#34;&#34;&#34;
    self.webSudo()
    self.setSessionBaseHeaders()
    self.sessionPostRequest( &#39;{url}secure/admin/user/UserBrowser.jspa&#39;.format( url=self.app[&#39;url&#39;] ), { &#39;userSearchFilter&#39;: &#39;&#39;, &#39;group&#39;: group, &#39;applicationFilter&#39;: &#39;&#39;, &#39;activeFilter&#39;: activeFilter, &#39;max&#39;: 1000000 } , True )
    should = WebDriverWait( self.browser, 10 ).until( EC.presence_of_element_located( ( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; results-count &#34;)]//*[contains(concat(&#34; &#34;, @class, &#34; &#34;), &#34; results-count-total &#34;)]&#39; ) ) ).text
    gms    = self.browser.find_elements( By.XPATH, &#39;//*[@data-cell-type=&#34;username&#34;]/ancestor::tr[position() = 1]&#39; )
    if len(gms) != int(should):
        raise Exception(&#39;Count-Missmatch with group members of &#34;{g}&#34;: {f} found, but {s} should have!&#39;.format(g=group, f=len(gms), s=should))
    users = []
    for i in gms:
        users.append( i.get_attribute( &#34;data-user&#34; ) )
    return users</code></pre>
</details>
</dd>
<dt id="Atlassian.Jira.getGroupMembersAPI"><code class="name flex">
<span>def <span class="ident">getGroupMembersAPI</span></span>(<span>self, group)</span>
</code></dt>
<dd>
<div class="desc"><p>get group members from API – sometimes a little bit buggy &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getGroupMembersAPI( self, group ):
    &#34;&#34;&#34;get group members from API – sometimes a little bit buggy ...&#34;&#34;&#34;
    sessionJ = self.toSession()
    stop = False
    i = 0
    users = []
    while True:
        limit = 50
        parameters = {
            &#39;groupname&#39;: group,
            &#39;startAt&#39;: ( i * limit ),
            &#39;maxResults&#39;: limit,
            &#39;includeInactiveUsers&#39;: &#39;false&#39;,
        }
        memberUrl = &#39;{url}rest/api/2/group/member?{params}&#39;.format( url=self.app[ &#39;url&#39; ], params=urllib.parse.urlencode( parameters ) )
        rspJ = sessionJ.get( memberUrl )

        if rspJ.status_code == 200:
            rsp = json.loads( rspJ.text )
            if rsp[ &#39;isLast&#39; ] == True:
                stop = True
            for u in rsp[&#39;values&#39;]:
                users.append( u[ &#39;name&#39; ] )
        else:
            print(&#39;rc: &#39; + str(rspJ.status_code))
            print(parameters)
            stop = True

        if stop or len( rsp[&#39;values&#39;] ) == 0:
            len( rsp[&#39;values&#39;] )
            break
        else:
            i += 1
    return users</code></pre>
</details>
</dd>
<dt id="Atlassian.Jira.getGroups"><code class="name flex">
<span>def <span class="ident">getGroups</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get list of groupnames existing in Jira</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getGroups( self ):
    &#34;&#34;&#34;get list of groupnames existing in Jira&#34;&#34;&#34;
    session = self.toSession()
    rspJ = session.get( &#39;{url}rest/api/2/groups/picker?maxResults={limit}&#39;.format( url=self.app[ &#39;url&#39; ], limit=5000 ) )
    jgroups = []
    if rspJ.status_code == 200:
        rsp = json.loads( rspJ.text )
        for g in rsp[&#39;groups&#39;]:
            jgroups.append( g[ &#39;name&#39; ] )
    return jgroups</code></pre>
</details>
</dd>
<dt id="Atlassian.Jira.getProjectKeys"><code class="name flex">
<span>def <span class="ident">getProjectKeys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a list of Project Keys of those Jira projects visible to logged in user</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getProjectKeys( self ):
    &#34;&#34;&#34;Get a list of Project Keys of those Jira projects visible to logged in user&#34;&#34;&#34;
    self.webSudo()
    self.get( self.app[ &#39;url&#39; ] + &#39;secure/project/BrowseProjects.jspa&#39; )
    while True:
        soup = self.toSoup()
        self.projectKeys += [ item.text for item in soup.select( &#39;tbody tr .cell-type-key&#39; ) ]
        try:
            nextBtn = soup.select( &#39;.aui-nav-next a&#39; )[0]
            check   = nextBtn[ &#39;data-page&#39; ]
            self.browser.find_element( By.XPATH, &#39;//*[contains(concat(&#34; &#34;, normalize-space(@class), &#34; &#34;), &#34; aui-nav-next &#34;)]//a&#39; ).click()
            time.sleep(5)
        except:
            break
    return self.projectKeys</code></pre>
</details>
</dd>
<dt id="Atlassian.Jira.getProjectLeads"><code class="name flex">
<span>def <span class="ident">getProjectLeads</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to retrieve active project leads for all Jira projects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getProjectLeads( self ):
    &#34;&#34;&#34;Function to retrieve active project leads for all Jira projects&#34;&#34;&#34;
    if len( self.projectKeys ) == 0:
        self.getProjectKeys()
    if len( self.projectLeads ) == 0:
        session = self.toSession()
        for pk in self.projectKeys:
            self.projectLeads[ projectKey ] = self.getActiveProjectLead( pk, session )
    return self.projectLeads</code></pre>
</details>
</dd>
<dt id="Atlassian.Jira.getUserApiInfo"><code class="name flex">
<span>def <span class="ident">getUserApiInfo</span></span>(<span>self, username, returnResponse=False, session=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to gather information about a user from API – if <code>returnResponse</code> is True, the whole request response is returned, otherwise only the decoded answer object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getUserApiInfo( self, username, returnResponse=False, session=None ):
    &#34;&#34;&#34;Function to gather information about a user from API – if `returnResponse` is True, the whole request response is returned, otherwise only the decoded answer object&#34;&#34;&#34;
    apiUrl = &#39;{url}rest/api/2/user?username={user}&#39;.format( url=self.app[&#39;url&#39;], user=urllib.parse.quote( username ) )
    return self.apiGetInfo( apiUrl, returnResponse, session )</code></pre>
</details>
</dd>
<dt id="Atlassian.Jira.getUserGroups"><code class="name flex">
<span>def <span class="ident">getUserGroups</span></span>(<span>self, username, session=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to gather groups of user</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getUserGroups( self, username, session=None ):
    &#34;&#34;&#34;Function to gather groups of user&#34;&#34;&#34;
    apiUrl = &#39;{url}rest/api/2/user?username={user}&amp;expand=groups&#39;.format( url=self.app[&#39;url&#39;], user=urllib.parse.quote( username ) )
    groups = self.apiGetInfo( apiUrl, session=session )
    return [ g[&#39;name&#39;] for g in groups[&#39;groups&#39;][&#39;items&#39;] ]</code></pre>
</details>
</dd>
<dt id="Atlassian.Jira.login"><code class="name flex">
<span>def <span class="ident">login</span></span>(<span>self, skipSSO=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Run Jira login</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def login( self, skipSSO=True ):
    &#34;&#34;&#34;Run Jira login&#34;&#34;&#34;
    loginUrl = self.app[ &#39;url&#39; ] + &#34;login.jsp&#34;
    if skipSSO:
        loginUrl += &#39;?nosso&#39;
    self.loadCookies( url=loginUrl )
    self.setSessionBaseHeaders()
    userObject = { &#34;os_username&#34;: self.app[ &#39;user&#39; ], &#34;os_password&#34;: self.app[ &#39;passwd&#39; ], }
    if os.getenv( &#34;PRINT_DEBUG_INFO&#34;, &#34;False&#34; ).lower() in [ &#34;1&#34;, &#34;true&#34;, &#34;t&#34;, &#34;y&#34;, &#34;yes&#34; ]:
        print( &#39;User is being logged in with those credentials:&#39; )
        print( userObject )
        print()
    self.sessionPostRequest( loginUrl, userObject, True, urlOverride=True )
    self.get( self.app[ &#39;url&#39; ] , False )</code></pre>
</details>
</dd>
<dt id="Atlassian.Jira.removeUserFromGroup"><code class="name flex">
<span>def <span class="ident">removeUserFromGroup</span></span>(<span>self, group, user, session=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove user from group</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeUserFromGroup( self, group, user, session=None ):
    &#34;&#34;&#34;Remove user from group&#34;&#34;&#34;
    if session == None:
        session = self.toSession( curl = True )
    requestData = {
        &#39;groupname&#39;: group,
        &#39;username&#39;:  user
    }
    rsp = session.delete( &#39;{url}rest/api/2/group/user?{params}&#39;.format( url=self.app[ &#39;url&#39; ], params=urllib.parse.urlencode( requestData ) ) )
    return rsp</code></pre>
</details>
</dd>
<dt id="Atlassian.Jira.setSessionBaseHeaders"><code class="name flex">
<span>def <span class="ident">setSessionBaseHeaders</span></span>(<span>self, api=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Api requests need special headers in Jira &hellip; sometimes &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setSessionBaseHeaders( self, api=False ):
    &#34;&#34;&#34;Api requests need special headers in Jira ... sometimes ...&#34;&#34;&#34;
    if not api:
        self.sessionBaseHeaders = None
    else:
        self.sessionBaseHeaders = {
            &#34;Content-Type&#34;:      &#34;application/json&#34;,
            &#34;X-Atlassian-Token&#34;: &#34;no-check&#34;
        }</code></pre>
</details>
</dd>
<dt id="Atlassian.Jira.webSudo"><code class="name flex">
<span>def <span class="ident">webSudo</span></span>(<span>self, adjustCookies=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the Jira WebSudo</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def webSudo( self, adjustCookies = True ):
    &#34;&#34;&#34;Run the Jira WebSudo&#34;&#34;&#34;
    authUrl    = &#39;{url}secure/admin/WebSudoAuthenticate!default.jspa&#39;.format( url=self.app[ &#39;url&#39; ] )
    sysInfoUrl = &#39;{url}secure/admin/ViewApplicationProperties.jspa&#39;.format( url=self.app[ &#39;url&#39; ] )
    super( Jira, self ).webSudo( authUrl, sysInfoUrl, adjustCookies )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="Atlassian.Atlassian" href="#Atlassian.Atlassian">Atlassian</a></b></code>:
<ul class="hlist">
<li><code><a title="Atlassian.Atlassian.getToken" href="#Atlassian.Atlassian.getToken">getToken</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Atlassian.Atlassian" href="#Atlassian.Atlassian">Atlassian</a></code></h4>
<ul class="">
<li><code><a title="Atlassian.Atlassian.getToken" href="#Atlassian.Atlassian.getToken">getToken</a></code></li>
<li><code><a title="Atlassian.Atlassian.webSudo" href="#Atlassian.Atlassian.webSudo">webSudo</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Atlassian.Confluence" href="#Atlassian.Confluence">Confluence</a></code></h4>
<ul class="">
<li><code><a title="Atlassian.Confluence.APIFileRequest" href="#Atlassian.Confluence.APIFileRequest">APIFileRequest</a></code></li>
<li><code><a title="Atlassian.Confluence.addNewSpacePermissions" href="#Atlassian.Confluence.addNewSpacePermissions">addNewSpacePermissions</a></code></li>
<li><code><a title="Atlassian.Confluence.adjustSpacePermissions" href="#Atlassian.Confluence.adjustSpacePermissions">adjustSpacePermissions</a></code></li>
<li><code><a title="Atlassian.Confluence.appInfo" href="#Atlassian.Confluence.appInfo">appInfo</a></code></li>
<li><code><a title="Atlassian.Confluence.callPermissionChangePage" href="#Atlassian.Confluence.callPermissionChangePage">callPermissionChangePage</a></code></li>
<li><code><a title="Atlassian.Confluence.checkLogin" href="#Atlassian.Confluence.checkLogin">checkLogin</a></code></li>
<li><code><a title="Atlassian.Confluence.cleanupPermissions" href="#Atlassian.Confluence.cleanupPermissions">cleanupPermissions</a></code></li>
<li><code><a title="Atlassian.Confluence.createPage" href="#Atlassian.Confluence.createPage">createPage</a></code></li>
<li><code><a title="Atlassian.Confluence.deletePage" href="#Atlassian.Confluence.deletePage">deletePage</a></code></li>
<li><code><a title="Atlassian.Confluence.fetchPermissionsFromRow" href="#Atlassian.Confluence.fetchPermissionsFromRow">fetchPermissionsFromRow</a></code></li>
<li><code><a title="Atlassian.Confluence.getAllSpacePermissions" href="#Atlassian.Confluence.getAllSpacePermissions">getAllSpacePermissions</a></code></li>
<li><code><a title="Atlassian.Confluence.getAllSpacePermissionsAsRepresentation" href="#Atlassian.Confluence.getAllSpacePermissionsAsRepresentation">getAllSpacePermissionsAsRepresentation</a></code></li>
<li><code><a title="Atlassian.Confluence.getBoolListFromRepresentation" href="#Atlassian.Confluence.getBoolListFromRepresentation">getBoolListFromRepresentation</a></code></li>
<li><code><a title="Atlassian.Confluence.getGroupMembers" href="#Atlassian.Confluence.getGroupMembers">getGroupMembers</a></code></li>
<li><code><a title="Atlassian.Confluence.getGroups" href="#Atlassian.Confluence.getGroups">getGroups</a></code></li>
<li><code><a title="Atlassian.Confluence.getPageContent" href="#Atlassian.Confluence.getPageContent">getPageContent</a></code></li>
<li><code><a title="Atlassian.Confluence.getPageInfo" href="#Atlassian.Confluence.getPageInfo">getPageInfo</a></code></li>
<li><code><a title="Atlassian.Confluence.getPageInfoByID" href="#Atlassian.Confluence.getPageInfoByID">getPageInfoByID</a></code></li>
<li><code><a title="Atlassian.Confluence.getPermissionRepresentation" href="#Atlassian.Confluence.getPermissionRepresentation">getPermissionRepresentation</a></code></li>
<li><code><a title="Atlassian.Confluence.getSpaceHomepageID" href="#Atlassian.Confluence.getSpaceHomepageID">getSpaceHomepageID</a></code></li>
<li><code><a title="Atlassian.Confluence.getSpaceKeyFromName" href="#Atlassian.Confluence.getSpaceKeyFromName">getSpaceKeyFromName</a></code></li>
<li><code><a title="Atlassian.Confluence.getSpaceKeys" href="#Atlassian.Confluence.getSpaceKeys">getSpaceKeys</a></code></li>
<li><code><a title="Atlassian.Confluence.getSpaceKeysGUI" href="#Atlassian.Confluence.getSpaceKeysGUI">getSpaceKeysGUI</a></code></li>
<li><code><a title="Atlassian.Confluence.getSpaceName" href="#Atlassian.Confluence.getSpaceName">getSpaceName</a></code></li>
<li><code><a title="Atlassian.Confluence.getSpacePermissions" href="#Atlassian.Confluence.getSpacePermissions">getSpacePermissions</a></code></li>
<li><code><a title="Atlassian.Confluence.getUserApiInfo" href="#Atlassian.Confluence.getUserApiInfo">getUserApiInfo</a></code></li>
<li><code><a title="Atlassian.Confluence.login" href="#Atlassian.Confluence.login">login</a></code></li>
<li><code><a title="Atlassian.Confluence.permissions" href="#Atlassian.Confluence.permissions">permissions</a></code></li>
<li><code><a title="Atlassian.Confluence.permissionsNames" href="#Atlassian.Confluence.permissionsNames">permissionsNames</a></code></li>
<li><code><a title="Atlassian.Confluence.recoverConfluencePermissions" href="#Atlassian.Confluence.recoverConfluencePermissions">recoverConfluencePermissions</a></code></li>
<li><code><a title="Atlassian.Confluence.removeSpacePermissions" href="#Atlassian.Confluence.removeSpacePermissions">removeSpacePermissions</a></code></li>
<li><code><a title="Atlassian.Confluence.selectObjectRowForSpacePermissionChange" href="#Atlassian.Confluence.selectObjectRowForSpacePermissionChange">selectObjectRowForSpacePermissionChange</a></code></li>
<li><code><a title="Atlassian.Confluence.setSessionBaseHeaders" href="#Atlassian.Confluence.setSessionBaseHeaders">setSessionBaseHeaders</a></code></li>
<li><code><a title="Atlassian.Confluence.setSpacePermissions" href="#Atlassian.Confluence.setSpacePermissions">setSpacePermissions</a></code></li>
<li><code><a title="Atlassian.Confluence.spaceKeys" href="#Atlassian.Confluence.spaceKeys">spaceKeys</a></code></li>
<li><code><a title="Atlassian.Confluence.spaceNames" href="#Atlassian.Confluence.spaceNames">spaceNames</a></code></li>
<li><code><a title="Atlassian.Confluence.submitSpacePermissionChange" href="#Atlassian.Confluence.submitSpacePermissionChange">submitSpacePermissionChange</a></code></li>
<li><code><a title="Atlassian.Confluence.updatePage" href="#Atlassian.Confluence.updatePage">updatePage</a></code></li>
<li><code><a title="Atlassian.Confluence.webSudo" href="#Atlassian.Confluence.webSudo">webSudo</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Atlassian.Jira" href="#Atlassian.Jira">Jira</a></code></h4>
<ul class="">
<li><code><a title="Atlassian.Jira.addUserToGroup" href="#Atlassian.Jira.addUserToGroup">addUserToGroup</a></code></li>
<li><code><a title="Atlassian.Jira.appInfo" href="#Atlassian.Jira.appInfo">appInfo</a></code></li>
<li><code><a title="Atlassian.Jira.checkLogin" href="#Atlassian.Jira.checkLogin">checkLogin</a></code></li>
<li><code><a title="Atlassian.Jira.createGroup" href="#Atlassian.Jira.createGroup">createGroup</a></code></li>
<li><code><a title="Atlassian.Jira.gatherAllProjectPermissions" href="#Atlassian.Jira.gatherAllProjectPermissions">gatherAllProjectPermissions</a></code></li>
<li><code><a title="Atlassian.Jira.gatherProjectPermissions" href="#Atlassian.Jira.gatherProjectPermissions">gatherProjectPermissions</a></code></li>
<li><code><a title="Atlassian.Jira.getActiveProjectLead" href="#Atlassian.Jira.getActiveProjectLead">getActiveProjectLead</a></code></li>
<li><code><a title="Atlassian.Jira.getGroupApiInfo" href="#Atlassian.Jira.getGroupApiInfo">getGroupApiInfo</a></code></li>
<li><code><a title="Atlassian.Jira.getGroupMembers" href="#Atlassian.Jira.getGroupMembers">getGroupMembers</a></code></li>
<li><code><a title="Atlassian.Jira.getGroupMembersAPI" href="#Atlassian.Jira.getGroupMembersAPI">getGroupMembersAPI</a></code></li>
<li><code><a title="Atlassian.Jira.getGroups" href="#Atlassian.Jira.getGroups">getGroups</a></code></li>
<li><code><a title="Atlassian.Jira.getProjectKeys" href="#Atlassian.Jira.getProjectKeys">getProjectKeys</a></code></li>
<li><code><a title="Atlassian.Jira.getProjectLeads" href="#Atlassian.Jira.getProjectLeads">getProjectLeads</a></code></li>
<li><code><a title="Atlassian.Jira.getUserApiInfo" href="#Atlassian.Jira.getUserApiInfo">getUserApiInfo</a></code></li>
<li><code><a title="Atlassian.Jira.getUserGroups" href="#Atlassian.Jira.getUserGroups">getUserGroups</a></code></li>
<li><code><a title="Atlassian.Jira.login" href="#Atlassian.Jira.login">login</a></code></li>
<li><code><a title="Atlassian.Jira.permissions" href="#Atlassian.Jira.permissions">permissions</a></code></li>
<li><code><a title="Atlassian.Jira.projectKeys" href="#Atlassian.Jira.projectKeys">projectKeys</a></code></li>
<li><code><a title="Atlassian.Jira.projectLeads" href="#Atlassian.Jira.projectLeads">projectLeads</a></code></li>
<li><code><a title="Atlassian.Jira.removeUserFromGroup" href="#Atlassian.Jira.removeUserFromGroup">removeUserFromGroup</a></code></li>
<li><code><a title="Atlassian.Jira.setSessionBaseHeaders" href="#Atlassian.Jira.setSessionBaseHeaders">setSessionBaseHeaders</a></code></li>
<li><code><a title="Atlassian.Jira.webSudo" href="#Atlassian.Jira.webSudo">webSudo</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>